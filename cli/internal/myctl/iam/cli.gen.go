// Package iam provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package iam

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"

	"github.com/spf13/cobra"
)

const (
	XAuthTokenHeaderScopes = "XAuthTokenHeader.Scopes"
	XUserIDHeaderScopes    = "XUserIDHeader.Scopes"
)

// Catalog defines model for Catalog.
type Catalog map[string]Endpoint

// CreateKeystoneApplicationCredentialInput defines model for CreateKeystoneApplicationCredentialInput.
type CreateKeystoneApplicationCredentialInput struct {
	ApplicationCredential struct {
		AccessRules  *[]map[string]interface{} `json:"access_rules,omitempty"`
		Description  *string                   `json:"description"`
		ExpiresAt    *string                   `json:"expires_at"`
		Name         string                    `json:"name"`
		Roles        *[]string                 `json:"roles,omitempty"`
		Secret       *string                   `json:"secret"`
		Unrestricted *bool                     `json:"unrestricted,omitempty"`
	} `json:"application_credential"`
}

// CreateKeystoneDomainInput defines model for CreateKeystoneDomainInput.
type CreateKeystoneDomainInput struct {
	Domain CreateKeystoneDomainInput_Domain `json:"domain"`
}

// CreateKeystoneDomainInput_Domain defines model for CreateKeystoneDomainInput.Domain.
type CreateKeystoneDomainInput_Domain struct {
	Description          *string                `json:"description,omitempty"`
	Enabled              bool                   `json:"enabled"`
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CreateKeystoneProjectInput defines model for CreateKeystoneProjectInput.
type CreateKeystoneProjectInput struct {
	Project CreateKeystoneProjectInput_Project `json:"project"`
}

// CreateKeystoneProjectInput_Project defines model for CreateKeystoneProjectInput.Project.
type CreateKeystoneProjectInput_Project struct {
	Description          *string                `json:"description,omitempty"`
	DomainId             string                 `json:"domain_id"`
	Enabled              bool                   `json:"enabled"`
	Name                 string                 `json:"name"`
	OrganizationId       *string                `json:"organization_id,omitempty"`
	Tags                 *[]string              `json:"tags,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CreateKeystoneRoleInput defines model for CreateKeystoneRoleInput.
type CreateKeystoneRoleInput struct {
	Role CreateKeystoneRoleInput_Role `json:"role"`
}

// CreateKeystoneRoleInput_Role defines model for CreateKeystoneRoleInput.Role.
type CreateKeystoneRoleInput_Role struct {
	Description          *string                `json:"description,omitempty"`
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CreateKeystoneTokenInput defines model for CreateKeystoneTokenInput.
type CreateKeystoneTokenInput struct {
	Auth CreateKeystoneTokenInputAuth `json:"auth"`
}

// CreateKeystoneTokenInputAuth defines model for CreateKeystoneTokenInputAuth.
type CreateKeystoneTokenInputAuth struct {
	Identity CreateKeystoneTokenInputAuthIdentity `json:"identity"`
	Scope    *CreateKeystoneTokenInputAuthScope   `json:"scope,omitempty"`
}

// CreateKeystoneTokenInputAuthIdentity defines model for CreateKeystoneTokenInputAuthIdentity.
type CreateKeystoneTokenInputAuthIdentity struct {
	Methods []string `json:"methods"`
	Token   struct {
		Id *string `json:"id,omitempty"`
	} `json:"token"`
}

// CreateKeystoneTokenInputAuthScope defines model for CreateKeystoneTokenInputAuthScope.
type CreateKeystoneTokenInputAuthScope struct {
	Project *CreateKeystoneTokenInputAuthScopeProject `json:"project,omitempty"`
}

// CreateKeystoneTokenInputAuthScopeProject defines model for CreateKeystoneTokenInputAuthScopeProject.
type CreateKeystoneTokenInputAuthScopeProject struct {
	Domain *struct {
		Id *string `json:"id,omitempty"`
	} `json:"domain,omitempty"`
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// CreateKeystoneUserInput defines model for CreateKeystoneUserInput.
type CreateKeystoneUserInput struct {
	User struct {
		DefaultProjectId string `json:"default_project_id"`
		DomainId         string `json:"domain_id"`
		Enabled          bool   `json:"enabled"`
		Name             string `json:"name"`
		Password         string `json:"password"`
	} `json:"user"`
}

// Endpoint defines model for Endpoint.
type Endpoint struct {
	Id        string `json:"id"`
	Interface string `json:"interface"`
	Region    string `json:"region"`
	Url       string `json:"url"`
}

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code int `json:"code"`

	// Message Error message
	Message string `json:"message"`
}

// KeystoneApplicationCredential defines model for KeystoneApplicationCredential.
type KeystoneApplicationCredential struct {
	AccessRules *[]struct {
		Id      *openapi_types.UUID `json:"id,omitempty"`
		Method  *string             `json:"method,omitempty"`
		Path    *string             `json:"path,omitempty"`
		Service *string             `json:"service,omitempty"`
	} `json:"access_rules,omitempty"`
	Description *string   `json:"description,omitempty"`
	ExpiresAt   time.Time `json:"expires_at"`
	Id          string    `json:"id"`
	Links       *struct {
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`
	Name         string              `json:"name"`
	ProjectId    string              `json:"project_id"`
	Roles        []KeystoneTokenRole `json:"roles"`
	Secret       string              `json:"secret"`
	Unrestricted *bool               `json:"unrestricted,omitempty"`
}

// KeystoneApplicationCredentialResponse defines model for KeystoneApplicationCredentialResponse.
type KeystoneApplicationCredentialResponse struct {
	ApplicationCredential KeystoneApplicationCredential `json:"application_credential"`
}

// KeystoneCatalog defines model for KeystoneCatalog.
type KeystoneCatalog struct {
	Endpoints []KeystoneEndpoint `json:"endpoints"`
	Id        string             `json:"id"`
	Name      string             `json:"name"`
	Type      string             `json:"type"`
}

// KeystoneDomain defines model for KeystoneDomain.
type KeystoneDomain struct {
	Description          string                 `json:"description"`
	Enabled              bool                   `json:"enabled"`
	Id                   string                 `json:"id"`
	Links                KeystoneSelfPagerLinks `json:"links"`
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// KeystoneDomainResponse defines model for KeystoneDomainResponse.
type KeystoneDomainResponse struct {
	Domain KeystoneDomain `json:"domain"`
}

// KeystoneDomainsResponse defines model for KeystoneDomainsResponse.
type KeystoneDomainsResponse struct {
	Domains []KeystoneDomain   `json:"domains"`
	Links   KeystonePagerLinks `json:"links"`
}

// KeystoneEndpoint defines model for KeystoneEndpoint.
type KeystoneEndpoint struct {
	Id        string `json:"id"`
	Interface string `json:"interface"`
	Region    string `json:"region"`
	RegionId  string `json:"region_id"`
	Url       string `json:"url"`
}

// KeystoneGroup defines model for KeystoneGroup.
type KeystoneGroup struct {
	DomainId          string                 `json:"domain_id"`
	Enabled           bool                   `json:"enabled"`
	Id                string                 `json:"id"`
	Links             KeystoneSelfPagerLinks `json:"links"`
	Name              string                 `json:"name"`
	Options           map[string]interface{} `json:"options"`
	PasswordExpiresAt *time.Time             `json:"password_expires_at"`
}

// KeystoneGroupResponse defines model for KeystoneGroupResponse.
type KeystoneGroupResponse struct {
	Group KeystoneGroup `json:"group"`
}

// KeystoneGroupsResponse defines model for KeystoneGroupsResponse.
type KeystoneGroupsResponse struct {
	Groups []KeystoneGroup    `json:"groups"`
	Links  KeystonePagerLinks `json:"links"`
}

// KeystonePagerLinks defines model for KeystonePagerLinks.
type KeystonePagerLinks struct {
	Next     *string `json:"next"`
	Previous *string `json:"previous"`
	Self     string  `json:"self"`
}

// KeystoneProject defines model for KeystoneProject.
type KeystoneProject struct {
	Description          string                 `json:"description"`
	DomainId             string                 `json:"domain_id"`
	Enabled              bool                   `json:"enabled"`
	Id                   string                 `json:"id"`
	IsDomain             bool                   `json:"is_domain"`
	Links                KeystoneSelfPagerLinks `json:"links"`
	Name                 string                 `json:"name"`
	ParentId             string                 `json:"parent_id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// KeystoneProjectResponse defines model for KeystoneProjectResponse.
type KeystoneProjectResponse struct {
	Project KeystoneProject `json:"project"`
}

// KeystoneProjectsResponse defines model for KeystoneProjectsResponse.
type KeystoneProjectsResponse struct {
	Links    KeystonePagerLinks `json:"links"`
	Projects []KeystoneProject  `json:"projects"`
}

// KeystoneRole defines model for KeystoneRole.
type KeystoneRole struct {
	Description          string                 `json:"description"`
	Id                   string                 `json:"id"`
	Links                KeystoneSelfPagerLinks `json:"links"`
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// KeystoneRoleAssignment defines model for KeystoneRoleAssignment.
type KeystoneRoleAssignment struct {
	Group *KeystoneRoleAssignmentGroup `json:"group,omitempty"`
	Links *KeystoneSelfPagerLinks      `json:"links,omitempty"`
	Role  *KeystoneRoleAssignmentRole  `json:"role,omitempty"`
	Scope *KeystoneRoleAssignmentScope `json:"scope,omitempty"`
	User  *KeystoneRoleAssignmentUser  `json:"user,omitempty"`
}

// KeystoneRoleAssignmentDomain defines model for KeystoneRoleAssignmentDomain.
type KeystoneRoleAssignmentDomain struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneRoleAssignmentGroup defines model for KeystoneRoleAssignmentGroup.
type KeystoneRoleAssignmentGroup struct {
	Domain struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	} `json:"domain"`
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneRoleAssignmentProject defines model for KeystoneRoleAssignmentProject.
type KeystoneRoleAssignmentProject struct {
	Domain struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	} `json:"domain"`
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneRoleAssignmentRole defines model for KeystoneRoleAssignmentRole.
type KeystoneRoleAssignmentRole struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneRoleAssignmentScope defines model for KeystoneRoleAssignmentScope.
type KeystoneRoleAssignmentScope struct {
	Domain  *KeystoneRoleAssignmentDomain  `json:"domain,omitempty"`
	Project *KeystoneRoleAssignmentProject `json:"project,omitempty"`
}

// KeystoneRoleAssignmentUser defines model for KeystoneRoleAssignmentUser.
type KeystoneRoleAssignmentUser struct {
	Domain struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	} `json:"domain"`
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneRoleAssignmentsResponse defines model for KeystoneRoleAssignmentsResponse.
type KeystoneRoleAssignmentsResponse struct {
	Links           KeystonePagerLinks       `json:"links"`
	RoleAssignments []KeystoneRoleAssignment `json:"role_assignments"`
}

// KeystoneRoleResponse defines model for KeystoneRoleResponse.
type KeystoneRoleResponse struct {
	Role KeystoneRole `json:"role"`
}

// KeystoneRolesResponse defines model for KeystoneRolesResponse.
type KeystoneRolesResponse struct {
	Links KeystonePagerLinks `json:"links"`
	Roles []KeystoneRole     `json:"roles"`
}

// KeystoneSelfPagerLinks defines model for KeystoneSelfPagerLinks.
type KeystoneSelfPagerLinks struct {
	Self string `json:"self"`
}

// KeystoneToken defines model for KeystoneToken.
type KeystoneToken struct {
	AuditIds  []string              `json:"audit_ids"`
	Catalog   []KeystoneCatalog     `json:"catalog"`
	ExpiresAt time.Time             `json:"expires_at"`
	IsDomain  bool                  `json:"is_domain"`
	IssuedAt  time.Time             `json:"issued_at"`
	Methods   []string              `json:"methods"`
	Project   *KeystoneTokenProject `json:"project,omitempty"`
	Roles     []KeystoneTokenRole   `json:"roles"`
	User      KeystoneTokenUser     `json:"user"`
}

// KeystoneTokenDomain defines model for KeystoneTokenDomain.
type KeystoneTokenDomain struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneTokenProject defines model for KeystoneTokenProject.
type KeystoneTokenProject struct {
	Domain KeystoneTokenDomain `json:"domain"`
	Id     string              `json:"id"`
	Name   string              `json:"name"`
}

// KeystoneTokenResponse defines model for KeystoneTokenResponse.
type KeystoneTokenResponse struct {
	Token KeystoneToken `json:"token"`
}

// KeystoneTokenRole defines model for KeystoneTokenRole.
type KeystoneTokenRole struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneTokenUser defines model for KeystoneTokenUser.
type KeystoneTokenUser struct {
	Domain            KeystoneTokenDomain `json:"domain"`
	Id                string              `json:"id"`
	Name              string              `json:"name"`
	PasswordExpiresAt time.Time           `json:"password_expires_at"`
}

// KeystoneUser defines model for KeystoneUser.
type KeystoneUser struct {
	DomainId          string                 `json:"domain_id"`
	Enabled           bool                   `json:"enabled"`
	Id                string                 `json:"id"`
	Links             KeystoneSelfPagerLinks `json:"links"`
	Name              string                 `json:"name"`
	Options           map[string]interface{} `json:"options"`
	PasswordExpiresAt *time.Time             `json:"password_expires_at"`
}

// KeystoneUserResponse defines model for KeystoneUserResponse.
type KeystoneUserResponse struct {
	User KeystoneUser `json:"user"`
}

// KeystoneUsers defines model for KeystoneUsers.
type KeystoneUsers struct {
	Links KeystonePagerLinks `json:"links"`
	Users []KeystoneUser     `json:"users"`
}

// KeystoneVersion defines model for KeystoneVersion.
type KeystoneVersion struct {
	Version KeystoneVersionData `json:"version"`
}

// KeystoneVersionData defines model for KeystoneVersionData.
type KeystoneVersionData struct {
	Id         string                     `json:"id"`
	Links      []KeystoneVersionLink      `json:"links"`
	MediaTypes []KeystoneVersionMediaType `json:"media-types"`
	Status     string                     `json:"status"`
	Updated    time.Time                  `json:"updated"`
}

// KeystoneVersionLink defines model for KeystoneVersionLink.
type KeystoneVersionLink struct {
	Href string `json:"href"`
	Rel  string `json:"rel"`
}

// KeystoneVersionMediaType defines model for KeystoneVersionMediaType.
type KeystoneVersionMediaType struct {
	Base string `json:"base"`
	Type string `json:"type"`
}

// Pubkey defines model for Pubkey.
type Pubkey struct {
	Key string `json:"key"`
}

// Pubkeys defines model for Pubkeys.
type Pubkeys struct {
	Pubkeys []Pubkey `json:"pubkeys"`
}

// UpdateKeystoneDomainInput defines model for UpdateKeystoneDomainInput.
type UpdateKeystoneDomainInput struct {
	Domain UpdateKeystoneDomainInput_Domain `json:"domain"`
}

// UpdateKeystoneDomainInput_Domain defines model for UpdateKeystoneDomainInput.Domain.
type UpdateKeystoneDomainInput_Domain struct {
	Description          *string                `json:"description,omitempty"`
	Enabled              *bool                  `json:"enabled,omitempty"`
	Name                 *string                `json:"name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdateKeystoneProjectInput defines model for UpdateKeystoneProjectInput.
type UpdateKeystoneProjectInput struct {
	Project UpdateKeystoneProjectInput_Project `json:"project"`
}

// UpdateKeystoneProjectInput_Project defines model for UpdateKeystoneProjectInput.Project.
type UpdateKeystoneProjectInput_Project struct {
	Description          *string                `json:"description,omitempty"`
	DomainId             *string                `json:"domain_id,omitempty"`
	Enabled              *bool                  `json:"enabled,omitempty"`
	Name                 *string                `json:"name,omitempty"`
	Tags                 *[]string              `json:"tags,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdateKeystoneRoleInput defines model for UpdateKeystoneRoleInput.
type UpdateKeystoneRoleInput struct {
	Role UpdateKeystoneRoleInput_Role `json:"role"`
}

// UpdateKeystoneRoleInput_Role defines model for UpdateKeystoneRoleInput.Role.
type UpdateKeystoneRoleInput_Role struct {
	Description          *string                `json:"description,omitempty"`
	Name                 *string                `json:"name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// User defines model for User.
type User struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// WebUser defines model for WebUser.
type WebUser struct {
	Catalog  Catalog           `json:"catalog"`
	Projects []KeystoneProject `json:"projects"`
	User     User              `json:"user"`
}

// GetKeystoneDomainsParams defines parameters for GetKeystoneDomains.
type GetKeystoneDomainsParams struct {
	// Name Filters the response by a domain name
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetKeystoneGroupsParams defines parameters for GetKeystoneGroups.
type GetKeystoneGroupsParams struct {
	// Name Filters the response by a group name
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetKeystoneProjectsParams defines parameters for GetKeystoneProjects.
type GetKeystoneProjectsParams struct {
	// Name Filters the response by a project name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Tags Filters the response by tags
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// GetKeystoneRoleAssignmentsParams defines parameters for GetKeystoneRoleAssignments.
type GetKeystoneRoleAssignmentsParams struct {
	// RoleId Filters the response by a role id
	RoleId *string `form:"role.id,omitempty" json:"role.id,omitempty"`

	// UserId Filters the response by a user id
	UserId *string `form:"user.id,omitempty" json:"user.id,omitempty"`

	// ScopeDomainId Filters the response by a domain id
	ScopeDomainId *string `form:"scope.domain.id,omitempty" json:"scope.domain.id,omitempty"`

	// ScopeProjectId Filters the response by a role assignment id
	ScopeProjectId *string `form:"scope.project.id,omitempty" json:"scope.project.id,omitempty"`
}

// GetKeystoneRolesParams defines parameters for GetKeystoneRoles.
type GetKeystoneRolesParams struct {
	// Name Filters the response by a role name
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetKeystoneUsersParams defines parameters for GetKeystoneUsers.
type GetKeystoneUsersParams struct {
	// Name Filters the response by a user name
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetPubkeysParams defines parameters for GetPubkeys.
type GetPubkeysParams struct {
	// Kind kind of public key
	Kind string `form:"kind" json:"kind"`
}

// GetWebUserParams defines parameters for GetWebUser.
type GetWebUserParams struct {
	// ProjectId project id
	ProjectId *string `form:"project_id,omitempty" json:"project_id,omitempty"`
}

// CreateKeystoneTokenJSONRequestBody defines body for CreateKeystoneToken for application/json ContentType.
type CreateKeystoneTokenJSONRequestBody = CreateKeystoneTokenInput

// CreateKeystoneDomainJSONRequestBody defines body for CreateKeystoneDomain for application/json ContentType.
type CreateKeystoneDomainJSONRequestBody = CreateKeystoneDomainInput

// UpdateKeystoneDomainByIDJSONRequestBody defines body for UpdateKeystoneDomainByID for application/json ContentType.
type UpdateKeystoneDomainByIDJSONRequestBody = UpdateKeystoneDomainInput

// CreateKeystoneProjectJSONRequestBody defines body for CreateKeystoneProject for application/json ContentType.
type CreateKeystoneProjectJSONRequestBody = CreateKeystoneProjectInput

// UpdateKeystoneProjectByIDJSONRequestBody defines body for UpdateKeystoneProjectByID for application/json ContentType.
type UpdateKeystoneProjectByIDJSONRequestBody = UpdateKeystoneProjectInput

// CreateKeystoneRoleJSONRequestBody defines body for CreateKeystoneRole for application/json ContentType.
type CreateKeystoneRoleJSONRequestBody = CreateKeystoneRoleInput

// UpdateKeystoneRoleByIDJSONRequestBody defines body for UpdateKeystoneRoleByID for application/json ContentType.
type UpdateKeystoneRoleByIDJSONRequestBody = UpdateKeystoneRoleInput

// CreateKeystoneUserJSONRequestBody defines body for CreateKeystoneUser for application/json ContentType.
type CreateKeystoneUserJSONRequestBody = CreateKeystoneUserInput

// CreateKeystoneApplicationCredentialJSONRequestBody defines body for CreateKeystoneApplicationCredential for application/json ContentType.
type CreateKeystoneApplicationCredentialJSONRequestBody = CreateKeystoneApplicationCredentialInput

// Getter for additional properties for CreateKeystoneDomainInput_Domain. Returns the specified
// element and whether it was found
func (a CreateKeystoneDomainInput_Domain) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateKeystoneDomainInput_Domain
func (a *CreateKeystoneDomainInput_Domain) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateKeystoneDomainInput_Domain to handle AdditionalProperties
func (a *CreateKeystoneDomainInput_Domain) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateKeystoneDomainInput_Domain to handle AdditionalProperties
func (a CreateKeystoneDomainInput_Domain) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateKeystoneProjectInput_Project. Returns the specified
// element and whether it was found
func (a CreateKeystoneProjectInput_Project) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateKeystoneProjectInput_Project
func (a *CreateKeystoneProjectInput_Project) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateKeystoneProjectInput_Project to handle AdditionalProperties
func (a *CreateKeystoneProjectInput_Project) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["domain_id"]; found {
		err = json.Unmarshal(raw, &a.DomainId)
		if err != nil {
			return fmt.Errorf("error reading 'domain_id': %w", err)
		}
		delete(object, "domain_id")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["organization_id"]; found {
		err = json.Unmarshal(raw, &a.OrganizationId)
		if err != nil {
			return fmt.Errorf("error reading 'organization_id': %w", err)
		}
		delete(object, "organization_id")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateKeystoneProjectInput_Project to handle AdditionalProperties
func (a CreateKeystoneProjectInput_Project) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["domain_id"], err = json.Marshal(a.DomainId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'domain_id': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.OrganizationId != nil {
		object["organization_id"], err = json.Marshal(a.OrganizationId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'organization_id': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateKeystoneRoleInput_Role. Returns the specified
// element and whether it was found
func (a CreateKeystoneRoleInput_Role) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateKeystoneRoleInput_Role
func (a *CreateKeystoneRoleInput_Role) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateKeystoneRoleInput_Role to handle AdditionalProperties
func (a *CreateKeystoneRoleInput_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateKeystoneRoleInput_Role to handle AdditionalProperties
func (a CreateKeystoneRoleInput_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for KeystoneDomain. Returns the specified
// element and whether it was found
func (a KeystoneDomain) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for KeystoneDomain
func (a *KeystoneDomain) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for KeystoneDomain to handle AdditionalProperties
func (a *KeystoneDomain) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["links"]; found {
		err = json.Unmarshal(raw, &a.Links)
		if err != nil {
			return fmt.Errorf("error reading 'links': %w", err)
		}
		delete(object, "links")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for KeystoneDomain to handle AdditionalProperties
func (a KeystoneDomain) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["description"], err = json.Marshal(a.Description)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'description': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["links"], err = json.Marshal(a.Links)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'links': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for KeystoneProject. Returns the specified
// element and whether it was found
func (a KeystoneProject) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for KeystoneProject
func (a *KeystoneProject) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for KeystoneProject to handle AdditionalProperties
func (a *KeystoneProject) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["domain_id"]; found {
		err = json.Unmarshal(raw, &a.DomainId)
		if err != nil {
			return fmt.Errorf("error reading 'domain_id': %w", err)
		}
		delete(object, "domain_id")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_domain"]; found {
		err = json.Unmarshal(raw, &a.IsDomain)
		if err != nil {
			return fmt.Errorf("error reading 'is_domain': %w", err)
		}
		delete(object, "is_domain")
	}

	if raw, found := object["links"]; found {
		err = json.Unmarshal(raw, &a.Links)
		if err != nil {
			return fmt.Errorf("error reading 'links': %w", err)
		}
		delete(object, "links")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["parent_id"]; found {
		err = json.Unmarshal(raw, &a.ParentId)
		if err != nil {
			return fmt.Errorf("error reading 'parent_id': %w", err)
		}
		delete(object, "parent_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for KeystoneProject to handle AdditionalProperties
func (a KeystoneProject) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["description"], err = json.Marshal(a.Description)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'description': %w", err)
	}

	object["domain_id"], err = json.Marshal(a.DomainId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'domain_id': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["is_domain"], err = json.Marshal(a.IsDomain)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'is_domain': %w", err)
	}

	object["links"], err = json.Marshal(a.Links)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'links': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["parent_id"], err = json.Marshal(a.ParentId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'parent_id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for KeystoneRole. Returns the specified
// element and whether it was found
func (a KeystoneRole) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for KeystoneRole
func (a *KeystoneRole) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for KeystoneRole to handle AdditionalProperties
func (a *KeystoneRole) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["links"]; found {
		err = json.Unmarshal(raw, &a.Links)
		if err != nil {
			return fmt.Errorf("error reading 'links': %w", err)
		}
		delete(object, "links")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for KeystoneRole to handle AdditionalProperties
func (a KeystoneRole) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["description"], err = json.Marshal(a.Description)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'description': %w", err)
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["links"], err = json.Marshal(a.Links)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'links': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateKeystoneDomainInput_Domain. Returns the specified
// element and whether it was found
func (a UpdateKeystoneDomainInput_Domain) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateKeystoneDomainInput_Domain
func (a *UpdateKeystoneDomainInput_Domain) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateKeystoneDomainInput_Domain to handle AdditionalProperties
func (a *UpdateKeystoneDomainInput_Domain) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateKeystoneDomainInput_Domain to handle AdditionalProperties
func (a UpdateKeystoneDomainInput_Domain) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateKeystoneProjectInput_Project. Returns the specified
// element and whether it was found
func (a UpdateKeystoneProjectInput_Project) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateKeystoneProjectInput_Project
func (a *UpdateKeystoneProjectInput_Project) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateKeystoneProjectInput_Project to handle AdditionalProperties
func (a *UpdateKeystoneProjectInput_Project) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["domain_id"]; found {
		err = json.Unmarshal(raw, &a.DomainId)
		if err != nil {
			return fmt.Errorf("error reading 'domain_id': %w", err)
		}
		delete(object, "domain_id")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateKeystoneProjectInput_Project to handle AdditionalProperties
func (a UpdateKeystoneProjectInput_Project) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.DomainId != nil {
		object["domain_id"], err = json.Marshal(a.DomainId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'domain_id': %w", err)
		}
	}

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateKeystoneRoleInput_Role. Returns the specified
// element and whether it was found
func (a UpdateKeystoneRoleInput_Role) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateKeystoneRoleInput_Role
func (a *UpdateKeystoneRoleInput_Role) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateKeystoneRoleInput_Role to handle AdditionalProperties
func (a *UpdateKeystoneRoleInput_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateKeystoneRoleInput_Role to handle AdditionalProperties
func (a UpdateKeystoneRoleInput_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

var file string
var controller ICLIController

type ICLIController interface {
	GetBaseURL() string
	RequestEditorFn(ctx context.Context, req *http.Request) error

	GetKeystoneVersion(ctx context.Context, res *GetKeystoneVersionResponse, err error)

	GetKeystoneDomains(ctx context.Context, res *GetKeystoneDomainsResponse, err error)

	CreateKeystoneDomain(ctx context.Context, res *CreateKeystoneDomainResponse, err error)

	DeleteKeystoneDomainByID(ctx context.Context, res *DeleteKeystoneDomainByIDResponse, err error)

	GetKeystoneDomainByID(ctx context.Context, res *GetKeystoneDomainByIDResponse, err error)

	UpdateKeystoneDomainByID(ctx context.Context, res *UpdateKeystoneDomainByIDResponse, err error)

	UnassignKeystoneRoleFromUserDomain(ctx context.Context, res *UnassignKeystoneRoleFromUserDomainResponse, err error)

	AssignKeystoneRoleToUserDomain(ctx context.Context, res *AssignKeystoneRoleToUserDomainResponse, err error)

	CreateKeystoneApplicationCredential(ctx context.Context, res *CreateKeystoneApplicationCredentialResponse, err error)
}

var getCmd = &cobra.Command{
	Use: "get",
}

var createCmd = &cobra.Command{
	Use: "create",
}

var updateCmd = &cobra.Command{
	Use: "update",
}

var deleteCmd = &cobra.Command{
	Use: "delete",
}

var GetKeystoneDomainsName string

func init() {
	controller = NewCLIController()

	getCmd.AddCommand(GetKeystoneVersion)

	GetKeystoneDomains.PersistentFlags().StringVarP(&GetKeystoneDomainsName, "name", "", "", "Filters the response by a domain name")

	getCmd.AddCommand(GetKeystoneDomains)

	CreateKeystoneDomain.PersistentFlags().StringVarP(&file, "file", "f", "", "file path")
	CreateKeystoneDomain.MarkPersistentFlagRequired("file")

	createCmd.AddCommand(CreateKeystoneDomain)

	deleteCmd.AddCommand(DeleteKeystoneDomainByID)

	getCmd.AddCommand(GetKeystoneDomainByID)

	UpdateKeystoneDomainByID.PersistentFlags().StringVarP(&file, "file", "f", "", "file path")
	UpdateKeystoneDomainByID.MarkPersistentFlagRequired("file")

	updateCmd.AddCommand(UpdateKeystoneDomainByID)

	CreateKeystoneApplicationCredential.PersistentFlags().StringVarP(&file, "file", "f", "", "file path")
	CreateKeystoneApplicationCredential.MarkPersistentFlagRequired("file")

	createCmd.AddCommand(CreateKeystoneApplicationCredential)

	RootCmd.AddCommand(getCmd)
	RootCmd.AddCommand(createCmd)
	RootCmd.AddCommand(deleteCmd)
	RootCmd.AddCommand(updateCmd)
}

var GetKeystoneVersion = &cobra.Command{
	Use:   "keystoneversion",
	Short: "Get keystone version",
	Long:  "Get keystone version",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.GetKeystoneVersionWithResponse(ctx)

		controller.GetKeystoneVersion(ctx, res, err)
	},
}

var GetKeystoneDomains = &cobra.Command{
	Use:   "keystonedomains",
	Short: "Get keystone domains",
	Long:  "Get keystone domains",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		params := &GetKeystoneDomainsParams{}

		if GetKeystoneDomainsName != "" {
			params.Name = &GetKeystoneDomainsName
		}

		res, err := client.GetKeystoneDomainsWithResponse(ctx, params)

		controller.GetKeystoneDomains(ctx, res, err)
	},
}

var CreateKeystoneDomain = &cobra.Command{
	Use:   "keystonedomain",
	Short: "Create a new keystone domain",
	Long:  "Create a new keystone domain",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		bytes, err := os.ReadFile(file)
		if err != nil {
			fmt.Println(err)
		}

		body := CreateKeystoneDomainJSONRequestBody{}
		err = json.Unmarshal(bytes, &body)
		if err != nil {
			fmt.Println(err)
		}

		res, err := client.CreateKeystoneDomainWithResponse(ctx, body)

		controller.CreateKeystoneDomain(ctx, res, err)
	},
}

var DeleteKeystoneDomainByID = &cobra.Command{
	Use:   "keystonedomainbyid <id>",
	Short: "Delete a domain by ID",
	Long:  "Delete a domain by ID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.DeleteKeystoneDomainByIDWithResponse(ctx, args[0])

		controller.DeleteKeystoneDomainByID(ctx, res, err)
	},
}

var GetKeystoneDomainByID = &cobra.Command{
	Use:   "keystonedomainbyid <id>",
	Short: "Get a domain by ID",
	Long:  "Get a domain by ID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.GetKeystoneDomainByIDWithResponse(ctx, args[0])

		controller.GetKeystoneDomainByID(ctx, res, err)
	},
}

var UpdateKeystoneDomainByID = &cobra.Command{
	Use:   "keystonedomainbyid <id>",
	Short: "Update a domain by ID",
	Long:  "Update a domain by ID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		bytes, err := os.ReadFile(file)
		if err != nil {
			fmt.Println(err)
		}

		body := UpdateKeystoneDomainByIDJSONRequestBody{}
		err = json.Unmarshal(bytes, &body)
		if err != nil {
			fmt.Println(err)
		}

		res, err := client.UpdateKeystoneDomainByIDWithResponse(ctx, args[0], body)

		controller.UpdateKeystoneDomainByID(ctx, res, err)
	},
}

var UnassignKeystoneRoleFromUserDomain = &cobra.Command{
	Use:   "unassignkeystonerolefromuserdomain <id> <userId> <roleId>",
	Short: "Unassign a role from a user on a domain",
	Long:  "Unassign a role to a user on a domain",
	Args:  cobra.ExactArgs(3),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.UnassignKeystoneRoleFromUserDomainWithResponse(ctx, args[0], args[1], args[2])

		controller.UnassignKeystoneRoleFromUserDomain(ctx, res, err)
	},
}

var AssignKeystoneRoleToUserDomain = &cobra.Command{
	Use:   "assignkeystoneroletouserdomain <id> <userId> <roleId>",
	Short: "Assign a role to a user on a domain",
	Long:  "Assign a role to a user on a domain",
	Args:  cobra.ExactArgs(3),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.AssignKeystoneRoleToUserDomainWithResponse(ctx, args[0], args[1], args[2])

		controller.AssignKeystoneRoleToUserDomain(ctx, res, err)
	},
}

var CreateKeystoneApplicationCredential = &cobra.Command{
	Use:   "keystoneapplicationcredential <userId>",
	Short: "Create a new keystone application credential",
	Long:  "Create a new keystone application credential",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		bytes, err := os.ReadFile(file)
		if err != nil {
			fmt.Println(err)
		}

		body := CreateKeystoneApplicationCredentialJSONRequestBody{}
		err = json.Unmarshal(bytes, &body)
		if err != nil {
			fmt.Println(err)
		}

		res, err := client.CreateKeystoneApplicationCredentialWithResponse(ctx, args[0], body)

		controller.CreateKeystoneApplicationCredential(ctx, res, err)
	},
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetKeystoneVersion request
	GetKeystoneVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneFederationAuthToken request
	CreateKeystoneFederationAuthToken(ctx context.Context, provider string, protocol string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneTokenWithBody request with any body
	CreateKeystoneTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeystoneToken(ctx context.Context, body CreateKeystoneTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneDomains request
	GetKeystoneDomains(ctx context.Context, params *GetKeystoneDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneDomainWithBody request with any body
	CreateKeystoneDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeystoneDomain(ctx context.Context, body CreateKeystoneDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeystoneDomainByID request
	DeleteKeystoneDomainByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneDomainByID request
	GetKeystoneDomainByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKeystoneDomainByIDWithBody request with any body
	UpdateKeystoneDomainByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKeystoneDomainByID(ctx context.Context, id string, body UpdateKeystoneDomainByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignKeystoneRoleFromUserDomain request
	UnassignKeystoneRoleFromUserDomain(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignKeystoneRoleToUserDomain request
	AssignKeystoneRoleToUserDomain(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneGroups request
	GetKeystoneGroups(ctx context.Context, params *GetKeystoneGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneGroupByID request
	GetKeystoneGroupByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneProjects request
	GetKeystoneProjects(ctx context.Context, params *GetKeystoneProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneProjectWithBody request with any body
	CreateKeystoneProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeystoneProject(ctx context.Context, body CreateKeystoneProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeystoneProjectByID request
	DeleteKeystoneProjectByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneProjectByID request
	GetKeystoneProjectByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKeystoneProjectByIDWithBody request with any body
	UpdateKeystoneProjectByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKeystoneProjectByID(ctx context.Context, id string, body UpdateKeystoneProjectByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignKeystoneRoleFromGroupProject request
	UnassignKeystoneRoleFromGroupProject(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignKeystoneRoleToGroupProject request
	AssignKeystoneRoleToGroupProject(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignKeystoneRoleFromUserProject request
	UnassignKeystoneRoleFromUserProject(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignKeystoneRoleToUserProject request
	AssignKeystoneRoleToUserProject(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneRoleAssignments request
	GetKeystoneRoleAssignments(ctx context.Context, params *GetKeystoneRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneRoles request
	GetKeystoneRoles(ctx context.Context, params *GetKeystoneRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneRoleWithBody request with any body
	CreateKeystoneRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeystoneRole(ctx context.Context, body CreateKeystoneRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeystoneRoleByID request
	DeleteKeystoneRoleByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneRoleByID request
	GetKeystoneRoleByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKeystoneRoleByIDWithBody request with any body
	UpdateKeystoneRoleByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKeystoneRoleByID(ctx context.Context, id string, body UpdateKeystoneRoleByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneUsers request
	GetKeystoneUsers(ctx context.Context, params *GetKeystoneUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneUserWithBody request with any body
	CreateKeystoneUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeystoneUser(ctx context.Context, body CreateKeystoneUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeystoneUserByID request
	DeleteKeystoneUserByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneUserByID request
	GetKeystoneUserByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneUserProjectsByUserID request
	GetKeystoneUserProjectsByUserID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneApplicationCredentialWithBody request with any body
	CreateKeystoneApplicationCredentialWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeystoneApplicationCredential(ctx context.Context, userId string, body CreateKeystoneApplicationCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPubkeys request
	GetPubkeys(ctx context.Context, params *GetPubkeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebUser request
	GetWebUser(ctx context.Context, params *GetWebUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetKeystoneVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneFederationAuthToken(ctx context.Context, provider string, protocol string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneFederationAuthTokenRequest(c.Server, provider, protocol)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneToken(ctx context.Context, body CreateKeystoneTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneDomains(ctx context.Context, params *GetKeystoneDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneDomainsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneDomainRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneDomain(ctx context.Context, body CreateKeystoneDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneDomainRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeystoneDomainByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeystoneDomainByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneDomainByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneDomainByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeystoneDomainByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeystoneDomainByIDRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeystoneDomainByID(ctx context.Context, id string, body UpdateKeystoneDomainByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeystoneDomainByIDRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignKeystoneRoleFromUserDomain(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignKeystoneRoleFromUserDomainRequest(c.Server, id, userId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignKeystoneRoleToUserDomain(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignKeystoneRoleToUserDomainRequest(c.Server, id, userId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneGroups(ctx context.Context, params *GetKeystoneGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneGroupByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneGroupByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneProjects(ctx context.Context, params *GetKeystoneProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneProject(ctx context.Context, body CreateKeystoneProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeystoneProjectByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeystoneProjectByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneProjectByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneProjectByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeystoneProjectByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeystoneProjectByIDRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeystoneProjectByID(ctx context.Context, id string, body UpdateKeystoneProjectByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeystoneProjectByIDRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignKeystoneRoleFromGroupProject(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignKeystoneRoleFromGroupProjectRequest(c.Server, id, groupId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignKeystoneRoleToGroupProject(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignKeystoneRoleToGroupProjectRequest(c.Server, id, groupId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignKeystoneRoleFromUserProject(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignKeystoneRoleFromUserProjectRequest(c.Server, id, userId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignKeystoneRoleToUserProject(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignKeystoneRoleToUserProjectRequest(c.Server, id, userId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneRoleAssignments(ctx context.Context, params *GetKeystoneRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneRoleAssignmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneRoles(ctx context.Context, params *GetKeystoneRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneRole(ctx context.Context, body CreateKeystoneRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeystoneRoleByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeystoneRoleByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneRoleByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneRoleByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeystoneRoleByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeystoneRoleByIDRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeystoneRoleByID(ctx context.Context, id string, body UpdateKeystoneRoleByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeystoneRoleByIDRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneUsers(ctx context.Context, params *GetKeystoneUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneUser(ctx context.Context, body CreateKeystoneUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeystoneUserByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeystoneUserByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneUserByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneUserByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneUserProjectsByUserID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneUserProjectsByUserIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneApplicationCredentialWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneApplicationCredentialRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneApplicationCredential(ctx context.Context, userId string, body CreateKeystoneApplicationCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneApplicationCredentialRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPubkeys(ctx context.Context, params *GetPubkeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPubkeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebUser(ctx context.Context, params *GetWebUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetKeystoneVersionRequest generates requests for GetKeystoneVersion
func NewGetKeystoneVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneFederationAuthTokenRequest generates requests for CreateKeystoneFederationAuthToken
func NewCreateKeystoneFederationAuthTokenRequest(server string, provider string, protocol string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "protocol", runtime.ParamLocationPath, protocol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/OS-FEDERATION/identity_providers/%s/protocols/%s/auth", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneTokenRequest calls the generic CreateKeystoneToken builder with application/json body
func NewCreateKeystoneTokenRequest(server string, body CreateKeystoneTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeystoneTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeystoneTokenRequestWithBody generates requests for CreateKeystoneToken with any type of body
func NewCreateKeystoneTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/auth/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKeystoneDomainsRequest generates requests for GetKeystoneDomains
func NewGetKeystoneDomainsRequest(server string, params *GetKeystoneDomainsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneDomainRequest calls the generic CreateKeystoneDomain builder with application/json body
func NewCreateKeystoneDomainRequest(server string, body CreateKeystoneDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeystoneDomainRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeystoneDomainRequestWithBody generates requests for CreateKeystoneDomain with any type of body
func NewCreateKeystoneDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeystoneDomainByIDRequest generates requests for DeleteKeystoneDomainByID
func NewDeleteKeystoneDomainByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneDomainByIDRequest generates requests for GetKeystoneDomainByID
func NewGetKeystoneDomainByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKeystoneDomainByIDRequest calls the generic UpdateKeystoneDomainByID builder with application/json body
func NewUpdateKeystoneDomainByIDRequest(server string, id string, body UpdateKeystoneDomainByIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKeystoneDomainByIDRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateKeystoneDomainByIDRequestWithBody generates requests for UpdateKeystoneDomainByID with any type of body
func NewUpdateKeystoneDomainByIDRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignKeystoneRoleFromUserDomainRequest generates requests for UnassignKeystoneRoleFromUserDomain
func NewUnassignKeystoneRoleFromUserDomainRequest(server string, id string, userId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains/%s/users/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignKeystoneRoleToUserDomainRequest generates requests for AssignKeystoneRoleToUserDomain
func NewAssignKeystoneRoleToUserDomainRequest(server string, id string, userId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains/%s/users/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneGroupsRequest generates requests for GetKeystoneGroups
func NewGetKeystoneGroupsRequest(server string, params *GetKeystoneGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneGroupByIDRequest generates requests for GetKeystoneGroupByID
func NewGetKeystoneGroupByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneProjectsRequest generates requests for GetKeystoneProjects
func NewGetKeystoneProjectsRequest(server string, params *GetKeystoneProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneProjectRequest calls the generic CreateKeystoneProject builder with application/json body
func NewCreateKeystoneProjectRequest(server string, body CreateKeystoneProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeystoneProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeystoneProjectRequestWithBody generates requests for CreateKeystoneProject with any type of body
func NewCreateKeystoneProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeystoneProjectByIDRequest generates requests for DeleteKeystoneProjectByID
func NewDeleteKeystoneProjectByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneProjectByIDRequest generates requests for GetKeystoneProjectByID
func NewGetKeystoneProjectByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKeystoneProjectByIDRequest calls the generic UpdateKeystoneProjectByID builder with application/json body
func NewUpdateKeystoneProjectByIDRequest(server string, id string, body UpdateKeystoneProjectByIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKeystoneProjectByIDRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateKeystoneProjectByIDRequestWithBody generates requests for UpdateKeystoneProjectByID with any type of body
func NewUpdateKeystoneProjectByIDRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignKeystoneRoleFromGroupProjectRequest generates requests for UnassignKeystoneRoleFromGroupProject
func NewUnassignKeystoneRoleFromGroupProjectRequest(server string, id string, groupId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s/groups/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignKeystoneRoleToGroupProjectRequest generates requests for AssignKeystoneRoleToGroupProject
func NewAssignKeystoneRoleToGroupProjectRequest(server string, id string, groupId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s/groups/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnassignKeystoneRoleFromUserProjectRequest generates requests for UnassignKeystoneRoleFromUserProject
func NewUnassignKeystoneRoleFromUserProjectRequest(server string, id string, userId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s/users/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignKeystoneRoleToUserProjectRequest generates requests for AssignKeystoneRoleToUserProject
func NewAssignKeystoneRoleToUserProjectRequest(server string, id string, userId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s/users/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneRoleAssignmentsRequest generates requests for GetKeystoneRoleAssignments
func NewGetKeystoneRoleAssignmentsRequest(server string, params *GetKeystoneRoleAssignmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/role_assignments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RoleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role.id", runtime.ParamLocationQuery, *params.RoleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user.id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScopeDomainId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope.domain.id", runtime.ParamLocationQuery, *params.ScopeDomainId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScopeProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope.project.id", runtime.ParamLocationQuery, *params.ScopeProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneRolesRequest generates requests for GetKeystoneRoles
func NewGetKeystoneRolesRequest(server string, params *GetKeystoneRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneRoleRequest calls the generic CreateKeystoneRole builder with application/json body
func NewCreateKeystoneRoleRequest(server string, body CreateKeystoneRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeystoneRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeystoneRoleRequestWithBody generates requests for CreateKeystoneRole with any type of body
func NewCreateKeystoneRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeystoneRoleByIDRequest generates requests for DeleteKeystoneRoleByID
func NewDeleteKeystoneRoleByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneRoleByIDRequest generates requests for GetKeystoneRoleByID
func NewGetKeystoneRoleByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKeystoneRoleByIDRequest calls the generic UpdateKeystoneRoleByID builder with application/json body
func NewUpdateKeystoneRoleByIDRequest(server string, id string, body UpdateKeystoneRoleByIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKeystoneRoleByIDRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateKeystoneRoleByIDRequestWithBody generates requests for UpdateKeystoneRoleByID with any type of body
func NewUpdateKeystoneRoleByIDRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKeystoneUsersRequest generates requests for GetKeystoneUsers
func NewGetKeystoneUsersRequest(server string, params *GetKeystoneUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneUserRequest calls the generic CreateKeystoneUser builder with application/json body
func NewCreateKeystoneUserRequest(server string, body CreateKeystoneUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeystoneUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeystoneUserRequestWithBody generates requests for CreateKeystoneUser with any type of body
func NewCreateKeystoneUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeystoneUserByIDRequest generates requests for DeleteKeystoneUserByID
func NewDeleteKeystoneUserByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneUserByIDRequest generates requests for GetKeystoneUserByID
func NewGetKeystoneUserByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneUserProjectsByUserIDRequest generates requests for GetKeystoneUserProjectsByUserID
func NewGetKeystoneUserProjectsByUserIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/users/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneApplicationCredentialRequest calls the generic CreateKeystoneApplicationCredential builder with application/json body
func NewCreateKeystoneApplicationCredentialRequest(server string, userId string, body CreateKeystoneApplicationCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeystoneApplicationCredentialRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewCreateKeystoneApplicationCredentialRequestWithBody generates requests for CreateKeystoneApplicationCredential with any type of body
func NewCreateKeystoneApplicationCredentialRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/users/%s/application_credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPubkeysRequest generates requests for GetPubkeys
func NewGetPubkeysRequest(server string, params *GetPubkeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pubkeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, params.Kind); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebUserRequest generates requests for GetWebUser
func NewGetWebUserRequest(server string, params *GetWebUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/web/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetKeystoneVersionWithResponse request
	GetKeystoneVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeystoneVersionResponse, error)

	// CreateKeystoneFederationAuthTokenWithResponse request
	CreateKeystoneFederationAuthTokenWithResponse(ctx context.Context, provider string, protocol string, reqEditors ...RequestEditorFn) (*CreateKeystoneFederationAuthTokenResponse, error)

	// CreateKeystoneTokenWithBodyWithResponse request with any body
	CreateKeystoneTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneTokenResponse, error)

	CreateKeystoneTokenWithResponse(ctx context.Context, body CreateKeystoneTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneTokenResponse, error)

	// GetKeystoneDomainsWithResponse request
	GetKeystoneDomainsWithResponse(ctx context.Context, params *GetKeystoneDomainsParams, reqEditors ...RequestEditorFn) (*GetKeystoneDomainsResponse, error)

	// CreateKeystoneDomainWithBodyWithResponse request with any body
	CreateKeystoneDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneDomainResponse, error)

	CreateKeystoneDomainWithResponse(ctx context.Context, body CreateKeystoneDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneDomainResponse, error)

	// DeleteKeystoneDomainByIDWithResponse request
	DeleteKeystoneDomainByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneDomainByIDResponse, error)

	// GetKeystoneDomainByIDWithResponse request
	GetKeystoneDomainByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneDomainByIDResponse, error)

	// UpdateKeystoneDomainByIDWithBodyWithResponse request with any body
	UpdateKeystoneDomainByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeystoneDomainByIDResponse, error)

	UpdateKeystoneDomainByIDWithResponse(ctx context.Context, id string, body UpdateKeystoneDomainByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeystoneDomainByIDResponse, error)

	// UnassignKeystoneRoleFromUserDomainWithResponse request
	UnassignKeystoneRoleFromUserDomainWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*UnassignKeystoneRoleFromUserDomainResponse, error)

	// AssignKeystoneRoleToUserDomainWithResponse request
	AssignKeystoneRoleToUserDomainWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*AssignKeystoneRoleToUserDomainResponse, error)

	// GetKeystoneGroupsWithResponse request
	GetKeystoneGroupsWithResponse(ctx context.Context, params *GetKeystoneGroupsParams, reqEditors ...RequestEditorFn) (*GetKeystoneGroupsResponse, error)

	// GetKeystoneGroupByIDWithResponse request
	GetKeystoneGroupByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneGroupByIDResponse, error)

	// GetKeystoneProjectsWithResponse request
	GetKeystoneProjectsWithResponse(ctx context.Context, params *GetKeystoneProjectsParams, reqEditors ...RequestEditorFn) (*GetKeystoneProjectsResponse, error)

	// CreateKeystoneProjectWithBodyWithResponse request with any body
	CreateKeystoneProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneProjectResponse, error)

	CreateKeystoneProjectWithResponse(ctx context.Context, body CreateKeystoneProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneProjectResponse, error)

	// DeleteKeystoneProjectByIDWithResponse request
	DeleteKeystoneProjectByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneProjectByIDResponse, error)

	// GetKeystoneProjectByIDWithResponse request
	GetKeystoneProjectByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneProjectByIDResponse, error)

	// UpdateKeystoneProjectByIDWithBodyWithResponse request with any body
	UpdateKeystoneProjectByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeystoneProjectByIDResponse, error)

	UpdateKeystoneProjectByIDWithResponse(ctx context.Context, id string, body UpdateKeystoneProjectByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeystoneProjectByIDResponse, error)

	// UnassignKeystoneRoleFromGroupProjectWithResponse request
	UnassignKeystoneRoleFromGroupProjectWithResponse(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*UnassignKeystoneRoleFromGroupProjectResponse, error)

	// AssignKeystoneRoleToGroupProjectWithResponse request
	AssignKeystoneRoleToGroupProjectWithResponse(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*AssignKeystoneRoleToGroupProjectResponse, error)

	// UnassignKeystoneRoleFromUserProjectWithResponse request
	UnassignKeystoneRoleFromUserProjectWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*UnassignKeystoneRoleFromUserProjectResponse, error)

	// AssignKeystoneRoleToUserProjectWithResponse request
	AssignKeystoneRoleToUserProjectWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*AssignKeystoneRoleToUserProjectResponse, error)

	// GetKeystoneRoleAssignmentsWithResponse request
	GetKeystoneRoleAssignmentsWithResponse(ctx context.Context, params *GetKeystoneRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*GetKeystoneRoleAssignmentsResponse, error)

	// GetKeystoneRolesWithResponse request
	GetKeystoneRolesWithResponse(ctx context.Context, params *GetKeystoneRolesParams, reqEditors ...RequestEditorFn) (*GetKeystoneRolesResponse, error)

	// CreateKeystoneRoleWithBodyWithResponse request with any body
	CreateKeystoneRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneRoleResponse, error)

	CreateKeystoneRoleWithResponse(ctx context.Context, body CreateKeystoneRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneRoleResponse, error)

	// DeleteKeystoneRoleByIDWithResponse request
	DeleteKeystoneRoleByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneRoleByIDResponse, error)

	// GetKeystoneRoleByIDWithResponse request
	GetKeystoneRoleByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneRoleByIDResponse, error)

	// UpdateKeystoneRoleByIDWithBodyWithResponse request with any body
	UpdateKeystoneRoleByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeystoneRoleByIDResponse, error)

	UpdateKeystoneRoleByIDWithResponse(ctx context.Context, id string, body UpdateKeystoneRoleByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeystoneRoleByIDResponse, error)

	// GetKeystoneUsersWithResponse request
	GetKeystoneUsersWithResponse(ctx context.Context, params *GetKeystoneUsersParams, reqEditors ...RequestEditorFn) (*GetKeystoneUsersResponse, error)

	// CreateKeystoneUserWithBodyWithResponse request with any body
	CreateKeystoneUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneUserResponse, error)

	CreateKeystoneUserWithResponse(ctx context.Context, body CreateKeystoneUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneUserResponse, error)

	// DeleteKeystoneUserByIDWithResponse request
	DeleteKeystoneUserByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneUserByIDResponse, error)

	// GetKeystoneUserByIDWithResponse request
	GetKeystoneUserByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneUserByIDResponse, error)

	// GetKeystoneUserProjectsByUserIDWithResponse request
	GetKeystoneUserProjectsByUserIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneUserProjectsByUserIDResponse, error)

	// CreateKeystoneApplicationCredentialWithBodyWithResponse request with any body
	CreateKeystoneApplicationCredentialWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneApplicationCredentialResponse, error)

	CreateKeystoneApplicationCredentialWithResponse(ctx context.Context, userId string, body CreateKeystoneApplicationCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneApplicationCredentialResponse, error)

	// GetPubkeysWithResponse request
	GetPubkeysWithResponse(ctx context.Context, params *GetPubkeysParams, reqEditors ...RequestEditorFn) (*GetPubkeysResponse, error)

	// GetWebUserWithResponse request
	GetWebUserWithResponse(ctx context.Context, params *GetWebUserParams, reqEditors ...RequestEditorFn) (*GetWebUserResponse, error)
}

type GetKeystoneVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneVersion
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneFederationAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneTokenResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneFederationAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneFederationAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneTokenResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneDomainsResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneDomainResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeystoneDomainByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteKeystoneDomainByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeystoneDomainByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneDomainByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneDomainResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneDomainByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneDomainByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKeystoneDomainByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneDomainResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateKeystoneDomainByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeystoneDomainByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignKeystoneRoleFromUserDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UnassignKeystoneRoleFromUserDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignKeystoneRoleFromUserDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignKeystoneRoleToUserDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AssignKeystoneRoleToUserDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignKeystoneRoleToUserDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneGroupsResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneGroupByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneGroupResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneGroupByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneGroupByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneProjectsResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneProjectResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeystoneProjectByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteKeystoneProjectByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeystoneProjectByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneProjectByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneProjectResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneProjectByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneProjectByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKeystoneProjectByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneProjectResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateKeystoneProjectByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeystoneProjectByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignKeystoneRoleFromGroupProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UnassignKeystoneRoleFromGroupProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignKeystoneRoleFromGroupProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignKeystoneRoleToGroupProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AssignKeystoneRoleToGroupProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignKeystoneRoleToGroupProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignKeystoneRoleFromUserProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UnassignKeystoneRoleFromUserProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignKeystoneRoleFromUserProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignKeystoneRoleToUserProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AssignKeystoneRoleToUserProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignKeystoneRoleToUserProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneRoleAssignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneRoleAssignmentsResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneRoleAssignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneRoleAssignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneRolesResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneRoleResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeystoneRoleByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteKeystoneRoleByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeystoneRoleByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneRoleByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneRoleResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneRoleByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneRoleByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKeystoneRoleByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneRoleResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateKeystoneRoleByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeystoneRoleByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneUsers
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneUser
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeystoneUserByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteKeystoneUserByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeystoneUserByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneUserByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneUser
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneUserByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneUserByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneUserProjectsByUserIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneUserResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneUserProjectsByUserIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneUserProjectsByUserIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneApplicationCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneApplicationCredentialResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneApplicationCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneApplicationCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPubkeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pubkeys
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPubkeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPubkeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebUser
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetWebUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetKeystoneVersionWithResponse request returning *GetKeystoneVersionResponse
func (c *ClientWithResponses) GetKeystoneVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeystoneVersionResponse, error) {
	rsp, err := c.GetKeystoneVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneVersionResponse(rsp)
}

// CreateKeystoneFederationAuthTokenWithResponse request returning *CreateKeystoneFederationAuthTokenResponse
func (c *ClientWithResponses) CreateKeystoneFederationAuthTokenWithResponse(ctx context.Context, provider string, protocol string, reqEditors ...RequestEditorFn) (*CreateKeystoneFederationAuthTokenResponse, error) {
	rsp, err := c.CreateKeystoneFederationAuthToken(ctx, provider, protocol, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneFederationAuthTokenResponse(rsp)
}

// CreateKeystoneTokenWithBodyWithResponse request with arbitrary body returning *CreateKeystoneTokenResponse
func (c *ClientWithResponses) CreateKeystoneTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneTokenResponse, error) {
	rsp, err := c.CreateKeystoneTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateKeystoneTokenWithResponse(ctx context.Context, body CreateKeystoneTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneTokenResponse, error) {
	rsp, err := c.CreateKeystoneToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneTokenResponse(rsp)
}

// GetKeystoneDomainsWithResponse request returning *GetKeystoneDomainsResponse
func (c *ClientWithResponses) GetKeystoneDomainsWithResponse(ctx context.Context, params *GetKeystoneDomainsParams, reqEditors ...RequestEditorFn) (*GetKeystoneDomainsResponse, error) {
	rsp, err := c.GetKeystoneDomains(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneDomainsResponse(rsp)
}

// CreateKeystoneDomainWithBodyWithResponse request with arbitrary body returning *CreateKeystoneDomainResponse
func (c *ClientWithResponses) CreateKeystoneDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneDomainResponse, error) {
	rsp, err := c.CreateKeystoneDomainWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneDomainResponse(rsp)
}

func (c *ClientWithResponses) CreateKeystoneDomainWithResponse(ctx context.Context, body CreateKeystoneDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneDomainResponse, error) {
	rsp, err := c.CreateKeystoneDomain(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneDomainResponse(rsp)
}

// DeleteKeystoneDomainByIDWithResponse request returning *DeleteKeystoneDomainByIDResponse
func (c *ClientWithResponses) DeleteKeystoneDomainByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneDomainByIDResponse, error) {
	rsp, err := c.DeleteKeystoneDomainByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeystoneDomainByIDResponse(rsp)
}

// GetKeystoneDomainByIDWithResponse request returning *GetKeystoneDomainByIDResponse
func (c *ClientWithResponses) GetKeystoneDomainByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneDomainByIDResponse, error) {
	rsp, err := c.GetKeystoneDomainByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneDomainByIDResponse(rsp)
}

// UpdateKeystoneDomainByIDWithBodyWithResponse request with arbitrary body returning *UpdateKeystoneDomainByIDResponse
func (c *ClientWithResponses) UpdateKeystoneDomainByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeystoneDomainByIDResponse, error) {
	rsp, err := c.UpdateKeystoneDomainByIDWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeystoneDomainByIDResponse(rsp)
}

func (c *ClientWithResponses) UpdateKeystoneDomainByIDWithResponse(ctx context.Context, id string, body UpdateKeystoneDomainByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeystoneDomainByIDResponse, error) {
	rsp, err := c.UpdateKeystoneDomainByID(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeystoneDomainByIDResponse(rsp)
}

// UnassignKeystoneRoleFromUserDomainWithResponse request returning *UnassignKeystoneRoleFromUserDomainResponse
func (c *ClientWithResponses) UnassignKeystoneRoleFromUserDomainWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*UnassignKeystoneRoleFromUserDomainResponse, error) {
	rsp, err := c.UnassignKeystoneRoleFromUserDomain(ctx, id, userId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignKeystoneRoleFromUserDomainResponse(rsp)
}

// AssignKeystoneRoleToUserDomainWithResponse request returning *AssignKeystoneRoleToUserDomainResponse
func (c *ClientWithResponses) AssignKeystoneRoleToUserDomainWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*AssignKeystoneRoleToUserDomainResponse, error) {
	rsp, err := c.AssignKeystoneRoleToUserDomain(ctx, id, userId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignKeystoneRoleToUserDomainResponse(rsp)
}

// GetKeystoneGroupsWithResponse request returning *GetKeystoneGroupsResponse
func (c *ClientWithResponses) GetKeystoneGroupsWithResponse(ctx context.Context, params *GetKeystoneGroupsParams, reqEditors ...RequestEditorFn) (*GetKeystoneGroupsResponse, error) {
	rsp, err := c.GetKeystoneGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneGroupsResponse(rsp)
}

// GetKeystoneGroupByIDWithResponse request returning *GetKeystoneGroupByIDResponse
func (c *ClientWithResponses) GetKeystoneGroupByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneGroupByIDResponse, error) {
	rsp, err := c.GetKeystoneGroupByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneGroupByIDResponse(rsp)
}

// GetKeystoneProjectsWithResponse request returning *GetKeystoneProjectsResponse
func (c *ClientWithResponses) GetKeystoneProjectsWithResponse(ctx context.Context, params *GetKeystoneProjectsParams, reqEditors ...RequestEditorFn) (*GetKeystoneProjectsResponse, error) {
	rsp, err := c.GetKeystoneProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneProjectsResponse(rsp)
}

// CreateKeystoneProjectWithBodyWithResponse request with arbitrary body returning *CreateKeystoneProjectResponse
func (c *ClientWithResponses) CreateKeystoneProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneProjectResponse, error) {
	rsp, err := c.CreateKeystoneProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateKeystoneProjectWithResponse(ctx context.Context, body CreateKeystoneProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneProjectResponse, error) {
	rsp, err := c.CreateKeystoneProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneProjectResponse(rsp)
}

// DeleteKeystoneProjectByIDWithResponse request returning *DeleteKeystoneProjectByIDResponse
func (c *ClientWithResponses) DeleteKeystoneProjectByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneProjectByIDResponse, error) {
	rsp, err := c.DeleteKeystoneProjectByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeystoneProjectByIDResponse(rsp)
}

// GetKeystoneProjectByIDWithResponse request returning *GetKeystoneProjectByIDResponse
func (c *ClientWithResponses) GetKeystoneProjectByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneProjectByIDResponse, error) {
	rsp, err := c.GetKeystoneProjectByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneProjectByIDResponse(rsp)
}

// UpdateKeystoneProjectByIDWithBodyWithResponse request with arbitrary body returning *UpdateKeystoneProjectByIDResponse
func (c *ClientWithResponses) UpdateKeystoneProjectByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeystoneProjectByIDResponse, error) {
	rsp, err := c.UpdateKeystoneProjectByIDWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeystoneProjectByIDResponse(rsp)
}

func (c *ClientWithResponses) UpdateKeystoneProjectByIDWithResponse(ctx context.Context, id string, body UpdateKeystoneProjectByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeystoneProjectByIDResponse, error) {
	rsp, err := c.UpdateKeystoneProjectByID(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeystoneProjectByIDResponse(rsp)
}

// UnassignKeystoneRoleFromGroupProjectWithResponse request returning *UnassignKeystoneRoleFromGroupProjectResponse
func (c *ClientWithResponses) UnassignKeystoneRoleFromGroupProjectWithResponse(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*UnassignKeystoneRoleFromGroupProjectResponse, error) {
	rsp, err := c.UnassignKeystoneRoleFromGroupProject(ctx, id, groupId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignKeystoneRoleFromGroupProjectResponse(rsp)
}

// AssignKeystoneRoleToGroupProjectWithResponse request returning *AssignKeystoneRoleToGroupProjectResponse
func (c *ClientWithResponses) AssignKeystoneRoleToGroupProjectWithResponse(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*AssignKeystoneRoleToGroupProjectResponse, error) {
	rsp, err := c.AssignKeystoneRoleToGroupProject(ctx, id, groupId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignKeystoneRoleToGroupProjectResponse(rsp)
}

// UnassignKeystoneRoleFromUserProjectWithResponse request returning *UnassignKeystoneRoleFromUserProjectResponse
func (c *ClientWithResponses) UnassignKeystoneRoleFromUserProjectWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*UnassignKeystoneRoleFromUserProjectResponse, error) {
	rsp, err := c.UnassignKeystoneRoleFromUserProject(ctx, id, userId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignKeystoneRoleFromUserProjectResponse(rsp)
}

// AssignKeystoneRoleToUserProjectWithResponse request returning *AssignKeystoneRoleToUserProjectResponse
func (c *ClientWithResponses) AssignKeystoneRoleToUserProjectWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*AssignKeystoneRoleToUserProjectResponse, error) {
	rsp, err := c.AssignKeystoneRoleToUserProject(ctx, id, userId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignKeystoneRoleToUserProjectResponse(rsp)
}

// GetKeystoneRoleAssignmentsWithResponse request returning *GetKeystoneRoleAssignmentsResponse
func (c *ClientWithResponses) GetKeystoneRoleAssignmentsWithResponse(ctx context.Context, params *GetKeystoneRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*GetKeystoneRoleAssignmentsResponse, error) {
	rsp, err := c.GetKeystoneRoleAssignments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneRoleAssignmentsResponse(rsp)
}

// GetKeystoneRolesWithResponse request returning *GetKeystoneRolesResponse
func (c *ClientWithResponses) GetKeystoneRolesWithResponse(ctx context.Context, params *GetKeystoneRolesParams, reqEditors ...RequestEditorFn) (*GetKeystoneRolesResponse, error) {
	rsp, err := c.GetKeystoneRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneRolesResponse(rsp)
}

// CreateKeystoneRoleWithBodyWithResponse request with arbitrary body returning *CreateKeystoneRoleResponse
func (c *ClientWithResponses) CreateKeystoneRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneRoleResponse, error) {
	rsp, err := c.CreateKeystoneRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateKeystoneRoleWithResponse(ctx context.Context, body CreateKeystoneRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneRoleResponse, error) {
	rsp, err := c.CreateKeystoneRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneRoleResponse(rsp)
}

// DeleteKeystoneRoleByIDWithResponse request returning *DeleteKeystoneRoleByIDResponse
func (c *ClientWithResponses) DeleteKeystoneRoleByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneRoleByIDResponse, error) {
	rsp, err := c.DeleteKeystoneRoleByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeystoneRoleByIDResponse(rsp)
}

// GetKeystoneRoleByIDWithResponse request returning *GetKeystoneRoleByIDResponse
func (c *ClientWithResponses) GetKeystoneRoleByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneRoleByIDResponse, error) {
	rsp, err := c.GetKeystoneRoleByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneRoleByIDResponse(rsp)
}

// UpdateKeystoneRoleByIDWithBodyWithResponse request with arbitrary body returning *UpdateKeystoneRoleByIDResponse
func (c *ClientWithResponses) UpdateKeystoneRoleByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeystoneRoleByIDResponse, error) {
	rsp, err := c.UpdateKeystoneRoleByIDWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeystoneRoleByIDResponse(rsp)
}

func (c *ClientWithResponses) UpdateKeystoneRoleByIDWithResponse(ctx context.Context, id string, body UpdateKeystoneRoleByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeystoneRoleByIDResponse, error) {
	rsp, err := c.UpdateKeystoneRoleByID(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeystoneRoleByIDResponse(rsp)
}

// GetKeystoneUsersWithResponse request returning *GetKeystoneUsersResponse
func (c *ClientWithResponses) GetKeystoneUsersWithResponse(ctx context.Context, params *GetKeystoneUsersParams, reqEditors ...RequestEditorFn) (*GetKeystoneUsersResponse, error) {
	rsp, err := c.GetKeystoneUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneUsersResponse(rsp)
}

// CreateKeystoneUserWithBodyWithResponse request with arbitrary body returning *CreateKeystoneUserResponse
func (c *ClientWithResponses) CreateKeystoneUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneUserResponse, error) {
	rsp, err := c.CreateKeystoneUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneUserResponse(rsp)
}

func (c *ClientWithResponses) CreateKeystoneUserWithResponse(ctx context.Context, body CreateKeystoneUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneUserResponse, error) {
	rsp, err := c.CreateKeystoneUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneUserResponse(rsp)
}

// DeleteKeystoneUserByIDWithResponse request returning *DeleteKeystoneUserByIDResponse
func (c *ClientWithResponses) DeleteKeystoneUserByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneUserByIDResponse, error) {
	rsp, err := c.DeleteKeystoneUserByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeystoneUserByIDResponse(rsp)
}

// GetKeystoneUserByIDWithResponse request returning *GetKeystoneUserByIDResponse
func (c *ClientWithResponses) GetKeystoneUserByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneUserByIDResponse, error) {
	rsp, err := c.GetKeystoneUserByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneUserByIDResponse(rsp)
}

// GetKeystoneUserProjectsByUserIDWithResponse request returning *GetKeystoneUserProjectsByUserIDResponse
func (c *ClientWithResponses) GetKeystoneUserProjectsByUserIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneUserProjectsByUserIDResponse, error) {
	rsp, err := c.GetKeystoneUserProjectsByUserID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneUserProjectsByUserIDResponse(rsp)
}

// CreateKeystoneApplicationCredentialWithBodyWithResponse request with arbitrary body returning *CreateKeystoneApplicationCredentialResponse
func (c *ClientWithResponses) CreateKeystoneApplicationCredentialWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneApplicationCredentialResponse, error) {
	rsp, err := c.CreateKeystoneApplicationCredentialWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneApplicationCredentialResponse(rsp)
}

func (c *ClientWithResponses) CreateKeystoneApplicationCredentialWithResponse(ctx context.Context, userId string, body CreateKeystoneApplicationCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneApplicationCredentialResponse, error) {
	rsp, err := c.CreateKeystoneApplicationCredential(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneApplicationCredentialResponse(rsp)
}

// GetPubkeysWithResponse request returning *GetPubkeysResponse
func (c *ClientWithResponses) GetPubkeysWithResponse(ctx context.Context, params *GetPubkeysParams, reqEditors ...RequestEditorFn) (*GetPubkeysResponse, error) {
	rsp, err := c.GetPubkeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPubkeysResponse(rsp)
}

// GetWebUserWithResponse request returning *GetWebUserResponse
func (c *ClientWithResponses) GetWebUserWithResponse(ctx context.Context, params *GetWebUserParams, reqEditors ...RequestEditorFn) (*GetWebUserResponse, error) {
	rsp, err := c.GetWebUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebUserResponse(rsp)
}

// ParseGetKeystoneVersionResponse parses an HTTP response from a GetKeystoneVersionWithResponse call
func ParseGetKeystoneVersionResponse(rsp *http.Response) (*GetKeystoneVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneFederationAuthTokenResponse parses an HTTP response from a CreateKeystoneFederationAuthTokenWithResponse call
func ParseCreateKeystoneFederationAuthTokenResponse(rsp *http.Response) (*CreateKeystoneFederationAuthTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneFederationAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneTokenResponse parses an HTTP response from a CreateKeystoneTokenWithResponse call
func ParseCreateKeystoneTokenResponse(rsp *http.Response) (*CreateKeystoneTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneDomainsResponse parses an HTTP response from a GetKeystoneDomainsWithResponse call
func ParseGetKeystoneDomainsResponse(rsp *http.Response) (*GetKeystoneDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneDomainsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneDomainResponse parses an HTTP response from a CreateKeystoneDomainWithResponse call
func ParseCreateKeystoneDomainResponse(rsp *http.Response) (*CreateKeystoneDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneDomainResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteKeystoneDomainByIDResponse parses an HTTP response from a DeleteKeystoneDomainByIDWithResponse call
func ParseDeleteKeystoneDomainByIDResponse(rsp *http.Response) (*DeleteKeystoneDomainByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeystoneDomainByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneDomainByIDResponse parses an HTTP response from a GetKeystoneDomainByIDWithResponse call
func ParseGetKeystoneDomainByIDResponse(rsp *http.Response) (*GetKeystoneDomainByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneDomainByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneDomainResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateKeystoneDomainByIDResponse parses an HTTP response from a UpdateKeystoneDomainByIDWithResponse call
func ParseUpdateKeystoneDomainByIDResponse(rsp *http.Response) (*UpdateKeystoneDomainByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKeystoneDomainByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneDomainResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnassignKeystoneRoleFromUserDomainResponse parses an HTTP response from a UnassignKeystoneRoleFromUserDomainWithResponse call
func ParseUnassignKeystoneRoleFromUserDomainResponse(rsp *http.Response) (*UnassignKeystoneRoleFromUserDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignKeystoneRoleFromUserDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssignKeystoneRoleToUserDomainResponse parses an HTTP response from a AssignKeystoneRoleToUserDomainWithResponse call
func ParseAssignKeystoneRoleToUserDomainResponse(rsp *http.Response) (*AssignKeystoneRoleToUserDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignKeystoneRoleToUserDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneGroupsResponse parses an HTTP response from a GetKeystoneGroupsWithResponse call
func ParseGetKeystoneGroupsResponse(rsp *http.Response) (*GetKeystoneGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneGroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneGroupByIDResponse parses an HTTP response from a GetKeystoneGroupByIDWithResponse call
func ParseGetKeystoneGroupByIDResponse(rsp *http.Response) (*GetKeystoneGroupByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneGroupByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneProjectsResponse parses an HTTP response from a GetKeystoneProjectsWithResponse call
func ParseGetKeystoneProjectsResponse(rsp *http.Response) (*GetKeystoneProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneProjectsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneProjectResponse parses an HTTP response from a CreateKeystoneProjectWithResponse call
func ParseCreateKeystoneProjectResponse(rsp *http.Response) (*CreateKeystoneProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteKeystoneProjectByIDResponse parses an HTTP response from a DeleteKeystoneProjectByIDWithResponse call
func ParseDeleteKeystoneProjectByIDResponse(rsp *http.Response) (*DeleteKeystoneProjectByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeystoneProjectByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneProjectByIDResponse parses an HTTP response from a GetKeystoneProjectByIDWithResponse call
func ParseGetKeystoneProjectByIDResponse(rsp *http.Response) (*GetKeystoneProjectByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneProjectByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateKeystoneProjectByIDResponse parses an HTTP response from a UpdateKeystoneProjectByIDWithResponse call
func ParseUpdateKeystoneProjectByIDResponse(rsp *http.Response) (*UpdateKeystoneProjectByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKeystoneProjectByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnassignKeystoneRoleFromGroupProjectResponse parses an HTTP response from a UnassignKeystoneRoleFromGroupProjectWithResponse call
func ParseUnassignKeystoneRoleFromGroupProjectResponse(rsp *http.Response) (*UnassignKeystoneRoleFromGroupProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignKeystoneRoleFromGroupProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssignKeystoneRoleToGroupProjectResponse parses an HTTP response from a AssignKeystoneRoleToGroupProjectWithResponse call
func ParseAssignKeystoneRoleToGroupProjectResponse(rsp *http.Response) (*AssignKeystoneRoleToGroupProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignKeystoneRoleToGroupProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnassignKeystoneRoleFromUserProjectResponse parses an HTTP response from a UnassignKeystoneRoleFromUserProjectWithResponse call
func ParseUnassignKeystoneRoleFromUserProjectResponse(rsp *http.Response) (*UnassignKeystoneRoleFromUserProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignKeystoneRoleFromUserProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssignKeystoneRoleToUserProjectResponse parses an HTTP response from a AssignKeystoneRoleToUserProjectWithResponse call
func ParseAssignKeystoneRoleToUserProjectResponse(rsp *http.Response) (*AssignKeystoneRoleToUserProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignKeystoneRoleToUserProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneRoleAssignmentsResponse parses an HTTP response from a GetKeystoneRoleAssignmentsWithResponse call
func ParseGetKeystoneRoleAssignmentsResponse(rsp *http.Response) (*GetKeystoneRoleAssignmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneRoleAssignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneRoleAssignmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneRolesResponse parses an HTTP response from a GetKeystoneRolesWithResponse call
func ParseGetKeystoneRolesResponse(rsp *http.Response) (*GetKeystoneRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneRolesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneRoleResponse parses an HTTP response from a CreateKeystoneRoleWithResponse call
func ParseCreateKeystoneRoleResponse(rsp *http.Response) (*CreateKeystoneRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneRoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteKeystoneRoleByIDResponse parses an HTTP response from a DeleteKeystoneRoleByIDWithResponse call
func ParseDeleteKeystoneRoleByIDResponse(rsp *http.Response) (*DeleteKeystoneRoleByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeystoneRoleByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneRoleByIDResponse parses an HTTP response from a GetKeystoneRoleByIDWithResponse call
func ParseGetKeystoneRoleByIDResponse(rsp *http.Response) (*GetKeystoneRoleByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneRoleByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneRoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateKeystoneRoleByIDResponse parses an HTTP response from a UpdateKeystoneRoleByIDWithResponse call
func ParseUpdateKeystoneRoleByIDResponse(rsp *http.Response) (*UpdateKeystoneRoleByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKeystoneRoleByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneRoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneUsersResponse parses an HTTP response from a GetKeystoneUsersWithResponse call
func ParseGetKeystoneUsersResponse(rsp *http.Response) (*GetKeystoneUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneUsers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneUserResponse parses an HTTP response from a CreateKeystoneUserWithResponse call
func ParseCreateKeystoneUserResponse(rsp *http.Response) (*CreateKeystoneUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteKeystoneUserByIDResponse parses an HTTP response from a DeleteKeystoneUserByIDWithResponse call
func ParseDeleteKeystoneUserByIDResponse(rsp *http.Response) (*DeleteKeystoneUserByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeystoneUserByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneUserByIDResponse parses an HTTP response from a GetKeystoneUserByIDWithResponse call
func ParseGetKeystoneUserByIDResponse(rsp *http.Response) (*GetKeystoneUserByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneUserByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneUserProjectsByUserIDResponse parses an HTTP response from a GetKeystoneUserProjectsByUserIDWithResponse call
func ParseGetKeystoneUserProjectsByUserIDResponse(rsp *http.Response) (*GetKeystoneUserProjectsByUserIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneUserProjectsByUserIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneApplicationCredentialResponse parses an HTTP response from a CreateKeystoneApplicationCredentialWithResponse call
func ParseCreateKeystoneApplicationCredentialResponse(rsp *http.Response) (*CreateKeystoneApplicationCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneApplicationCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneApplicationCredentialResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPubkeysResponse parses an HTTP response from a GetPubkeysWithResponse call
func ParseGetPubkeysResponse(rsp *http.Response) (*GetPubkeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPubkeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pubkeys
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWebUserResponse parses an HTTP response from a GetWebUserWithResponse call
func ParseGetWebUserResponse(rsp *http.Response) (*GetWebUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+w9aXPbOLJ/hcX3qt4XWaTkM/70PHGS9c7sxBXbu6nKulwQCVmciMcAoBNtSv99CxdP",
	"gCApybIzzJfIItDoG93oJvTD9uIwiSMYEWyf/7Cxt4AhYB/fAgKW8SP9CHw/IEEcgeU1ihOISADZkP9F",
	"cG6f2//j5EAcAcF5F/lJHETEXo9sskqgfW7Hsz+gx754iyAg8Fe4wiSO4EWSLAMP0BXeIujDiARgeRUl",
	"KaGLJKUlQT72wcsGK8Z5HsT4AaVL/jf8DsJkCe3zL/cjOyAwZN/WEBNfAITAiv7tQ+yhIKHL0fFRulyC",
	"GQVDUAqz4ZigIHqk4+H3JEAQPwBSWtSeupPTA/f0YDq5nZyeH07Pp2f2yAwuAiEsA8IQPQUetBWDUdyG",
	"1nx8lVYMPQRJKzLTCEH6l0egX1pxDpY4nzCL4yUEkb2m2ME/0wDR4V84Wfc1vaiM0oj63qhPl3EIgkij",
	"QD572KDV61F1RlkH6jKPKK/8wrOM7lyClVkqhuSQjKwRRJhZcY1i+kDDi4Q/3SYzOGYPgb81Vo3sGD2C",
	"KPgP1wQNZAIeGX5t1b1ZAEU6jMKQXDRL41O8hBpRUOPdphw66J2RQIabmbrb+CvUWR1IycK0Y+igXdC5",
	"NedAv+yC04XAoIxXwLwKWW2C25WEQX2oFydwE2A3DECV2gzNrhRfFegrUx5Csoj9TjYzsgkFruKiWtWa",
	"1UpiIMF2pe1G8lrr1DYSgnCdKkJa4HWdY6Hbf3rxcGRrHKDe4A3I32GINFabYogUFMA5SJfkQTBa55F3",
	"sRMkAONvMfLNnk2BpNq9j6Tvz2Ab/SFji0pbs5i3nXRHdhARiObAU1OL4KPOvaeIxbzzGIU01LRTFNRD",
	"wpoTsYsrZvA5NCU9CMUKBfBiH9b2ID7YYs9GOWKUGxlkuvgjRBR0CDEGj1ow8rGJJrGcHH6/HtmNWYU5",
	"UcicoUqAeRzunvqnkzf+3HXnh0dv4PzMh6en/vHRFPpzd+J6RR6kKWN9TYjcAZbhfnh3qxqaAL575QOd",
	"p+nYdUJIo3CsmiIzhdKsMI4CErMhozauwpAP5YAL3LbyYN2aU1lma47tbinT2YE7PZie3k7Ozg/d8+M3",
	"Y5f9K/LWBwQekCBUZkRVoR2f+SeT+fwMnsDDI+B5s8Pjs9Mjd3LiT/wZOJupYCyD6KtCHzBczsvAF4Qk",
	"544jvhh7cejIbdt5OnSo08DO3D89O/GPT47cqXfkT07eTA5Pp/DUh9D1XXd27KiTHuy0QN3oDGrSraeX",
	"TfoxsssevyCqw4l3Mp3P3PnMPzo7nr15cwzPZu6J6x3OXf/NWWO2mhlc025d2mlpGN2cwOaooXfgz6e/",
	"fwVHZ2HyZG8/lS3uIJykkkZnSJWYp/K1jW7rE8RJHGHY5TykDTvVPnKDRFwCLhwelfGFYovsLnrFgVIm",
	"+W4xkZxviiFyXMWMUUHcTdRfPu8Zg4b6zHO14e4NXM6vwSNEv7FZrTPIov4XiSgGWyw3H9kxe0I/cczM",
	"HNSrfR5FtyFOyKPDKUp5JjYh0l2bJUp1Xe4ktqLIlNS1Y/fzBa78kS4r2G5Ym6+lD3ElBz6gOE104u2V",
	"xDyrVebW1eh0auTLpOehHIUpwyvDqXCTYyhkW7lbUK3dzUswoelt81HKtA2ruQJUqeAgjDhgAxLd/YNA",
	"Z3fuQeDVhs0FKDXyIvidKEzWWEFIEHwK4hT3mStj705ugk1qpPJFHYbr/C5+yLe++qxdOZcEIBhpTnpa",
	"2r0uOMhBF6nrFTQICeptseXRYFUjuhz4V+Y2OIbehpylEt29SkaRoRySLdCG7Z+2XLp4meFsD32kjLnA",
	"OHiMQqiKrTrtT2Vg2fawIVdk2ak7BjIJb1XxUIMQtY5Rds7cHcQdnak821CPv+xy+t5dadprQ2O8+az4",
	"bQn0qE06VebBdmokr50L0n3uWSE11bRuibbS2PINqx+YxkJcg1v4a6vVbiIPul88gHyRzhFIZU80BSK1",
	"9druu3rqu2557dshirN2x/5+PG/F6XbsrUQR2tLIdtOzW3XrAUj9gGYPHRsZvPx8uhMr5bm2AmSLE5Su",
	"6VyAcQr9ThB7tXV0dM9MFIVUYgelnC4RIQOUBYLlJiGpHLnEK+WZYsqZs3tUaE6RhqGt+pfw2GOAWRLL",
	"hht5kZZNt7Gcv+3J0HvPrAWpNRk1hPTtRnXd3JsgTSHMzqXY7XC4swqowTexpYkjwwn9yzyhpzLT23IX",
	"L6908EafTGfhrYZgqYTYabPj2BtCMA66DVv/CREWx2dlwp7yB23QEnAuAQE1bCSoFniw+W09Zcb7TgwU",
	"K1ExqOKFEPoBOKDf9gb9DwridpWoW0sIIKk6mEoTaoJ+T8/ILE5Az2FJLpUJayEJxp+aJBaMC6aInCK2",
	"NO9hDBgf2wKhnKs1rGYAb9KdwaaLwSpErtPZV6hofBZfNgOng/RAFR4lyR+0Uj6BnfEgXoBV4XLHlOV1",
	"vfTS+7WWMrE/xWstPV5Z6f8iSpl/L+JFlJ4vnajDwB2G5f+CM/WahUOExjcN8jOD7Rfu2qXK+uBpVKz1",
	"SYKUHfAYeikKyOqGwuQM+HyRkgVLMv4Ggc/RKHdz3y6g5aWYxKEFUrKIkXiNi7Xs2Of2gs+TgrK/H9Bh",
	"BzxDy2lNgl+5s/zM3la43N5ylAkHxfZsudaadTnNY97wHhHAHQoMQbDkwwgE4f/jb+DxEaJxEOdQb/h3",
	"1sX1lXULQSjaj3iLMD53nMKkak+1fWFh1oDKZpMFIFaKIbaAJeVEYgQtgC0QWaJX1SKx5cMwjjBBgEBr",
	"DgFJEcRWEFlkAa2PCYwotMOxa+EEesFcdHOyOMODIjYX2F8kwFtAazp2a3h/+/ZtDNjjcYweHTEXO79d",
	"vX33+827g+nYHS9IuGRqClGIP85vZBe6gniHjXEo7wOyLHLuukCrPcqjWnsydscuT6ZgBJLAPrcP2Ve8",
	"RZ5ppfNVGI3zdMjKrLwnuMzmD5BYcpwl4TOwiLHmyueDqhE3NSGezrC1pq4rFUSUeAvNss4fmDtFboYd",
	"41GugmWsaxivR/bR589bQ4G/8KFYOI3g9wR6BPoW5GNG8hWbfSxecEf8LWechiFAK71g+Wb7xfaWgX1P",
	"5xe1xPl4c/D+3eW7Txe3Vx9/z9r2HxIUPwU+RNj5IT+unQTFJPbiJf+SfVw78v3GJMYKZeMvXFnAiuC3",
	"HDnp5Mo6V3456z30xcPM1fKeGRBCwhLRL9XFJKbs3Yt5Nl+6QPYmSeaq5GC7uDXww4NcaLXNU7Ek40Pb",
	"JdngTkveP4PdlQ8eFXrIBGahbMRge1T7Klvyl/t1yR6bdL9mh9SMHPYM78KapP1QvYOY/BL7q61xUPsu",
	"9Locd1FNXw/a/JK0uZ+uFjr/zRFG3oyvjTAusyGN7v19sKRPWGAnhWfNVhYQa1jiRJd53j9TiFa56xWP",
	"9utmq69UKMT0qGLdoKBanSoHN6NOfjMrzTQ5zks5aPees3iOtSfXWXn5qCkOFzY3eFGjFy03dmsjcaHU",
	"zo/AX3MVXkKieE38kn2fe73Zyrq6rGkxH1WW6y8rNrDRyV5dWvG8ijtPsxk6ysCWnSJsEtIe1ckUK/Nl",
	"/UG9GiRfdYLaTdmgM7UteSOFmUPiLXakL4Pne4Hbs1EvE0A1oqaZ/IDepJyqms9L0s/tRwf6KtcQHbxG",
	"G9HpefuwQFyl8YP+90D/Zh16zg/WK2wIG+4i3kxsAYsOpxYALArIiqMMp7rViVnF8tl7FId3GKIsNN63",
	"/Y0MazIqm1cUHN3qspLNDcsKwW0/emJrp0J40LfmKA5V8h7ssm4ZOl4pNrRUEWhd9DCzi5qR3caDib0C",
	"E8sMTC3nwbza2kPzJphfJaDMbbqcixeSnA/yIoCex44Mqxd/6li5psF06ChYPWhu5cxR8kWtmtmpTUPu",
	"zdXFmHozefXIbDj4V5d4l28yacopOIFDSlFLu4uKVdPPYuOVuVpTaInSKuh1Pqan4xSrbOQ6R22XE9cX",
	"qBYRj/JFWjckPodl1C7SMLnuTHiDaejUumOJSPaVNteIrrNRuy8Slfp/93QOVL1tpslpS1Mf3LaxTpQU",
	"3vZXuvD2pSHJ9Ta1ISHNHhGHXGUP1SG59FAeUpSHytJvLgg1a0p9199MTV5XaDr4ua2EpzV1NNWBmnVS",
	"+T7Mi1LLXZeChhjgZ6oGVcyjcfPPThvY/1spAfHkkR3G6aJdXRGIpe558Lt34xtt4YREMvZnrwQpxD5Y",
	"pbYWpOZW2/JPCxNTFYAG83qdVaDBtNrWgVScat7/dtcA0XXzu8MQvSLjHHog6nX9wTo7NEH02PfMxqXr",
	"exgM69V2PgxG1bL1QbvjqW4aNVfuCkKR94Vqz/Iq96X2L+SxRcXPkNTLa/TpmF/zs3kZT7BOuxh9usXF",
	"RBOVdjl2+feYj9rishUpmtYXOmRC4DkOS3V38JqKljW9HRyHybKVHqODmzD6hk09wktviSpfU9xGQwe1",
	"XKk1qWNBnd1t1FxN/8SH7L6Unl8Ftacz9NJt3U0H6MyohtNzYwUdyUvL696xfe2cMbtN4ZyKr0fdScaC",
	"z10yZ+sO9XJFvbwg8eZieYNqVHbQDfTiddXIBx+2YXW8rHym0niDBtbvOXw5Srjriviwlf8EhfCiJVT3",
	"8Ozu6W2+/3Enbp3umeqw84iXnupwGk0pDmfvoI2VFCdjS5cUR1wu2pTi3OHs3rndpjjsgrJ9+kVx/are",
	"HzIjGvyhMbVJ5T22dbfYPrVhzG6T2lCx9YgeZC3kuVMbtu6Q2ihSm4LEm1ObBtWo7Jgb6MXrSm0G39Uz",
	"pSkqnd5jtXszjY7/P9zqvbRC4Rj/suJ3c/5lFLVV8jEorEphqyqm09ms6aiA5oOHILszGSw739taAGPl",
	"YAyh40U+6W1xzpa1vE/Lwv1zRLRK+vca4ioxGvritxv+am2lfm/E08Qp/CSNcmP5BEmKImwl6WwZeGyV",
	"fytPCuSP3hjs62sQ+dTCcniaIwE68MVsH5I4hYwKhAx3fVfv2Vdojy017xucOfJnSRpVjw5S65z80RXz",
	"ZffMeWg7RMSAhz32hkhSBg3b/Db5ouLwBcqzaz9IIwBA9CQVKP9Jk3PHmUxPx+7YHU/s9f36vwEAAP//",
	"w/+TlQ2hAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
