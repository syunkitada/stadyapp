// Package iam provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package iam

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"

	"github.com/spf13/cobra"
)

const (
	XAuthTokenHeaderScopes = "XAuthTokenHeader.Scopes"
	XUserIDHeaderScopes    = "XUserIDHeader.Scopes"
)

// Catalog defines model for Catalog.
type Catalog map[string]Endpoint

// CreateKeystoneApplicationCredentialInput defines model for CreateKeystoneApplicationCredentialInput.
type CreateKeystoneApplicationCredentialInput struct {
	ApplicationCredential struct {
		AccessRules  *[]map[string]interface{} `json:"access_rules,omitempty"`
		Description  *string                   `json:"description"`
		ExpiresAt    *string                   `json:"expires_at"`
		Name         string                    `json:"name"`
		Roles        *[]string                 `json:"roles,omitempty"`
		Secret       *string                   `json:"secret"`
		Unrestricted *bool                     `json:"unrestricted,omitempty"`
	} `json:"application_credential"`
}

// CreateKeystoneDomainInput defines model for CreateKeystoneDomainInput.
type CreateKeystoneDomainInput struct {
	Domain CreateKeystoneDomainInput_Domain `json:"domain"`
}

// CreateKeystoneDomainInput_Domain defines model for CreateKeystoneDomainInput.Domain.
type CreateKeystoneDomainInput_Domain struct {
	Description          *string                `json:"description,omitempty"`
	Enabled              bool                   `json:"enabled"`
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CreateKeystoneProjectInput defines model for CreateKeystoneProjectInput.
type CreateKeystoneProjectInput struct {
	Project CreateKeystoneProjectInput_Project `json:"project"`
}

// CreateKeystoneProjectInput_Project defines model for CreateKeystoneProjectInput.Project.
type CreateKeystoneProjectInput_Project struct {
	Description          *string                `json:"description,omitempty"`
	DomainId             string                 `json:"domain_id"`
	Enabled              bool                   `json:"enabled"`
	Name                 string                 `json:"name"`
	OrganizationId       *string                `json:"organization_id,omitempty"`
	Tags                 *[]string              `json:"tags,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CreateKeystoneRoleInput defines model for CreateKeystoneRoleInput.
type CreateKeystoneRoleInput struct {
	Role CreateKeystoneRoleInput_Role `json:"role"`
}

// CreateKeystoneRoleInput_Role defines model for CreateKeystoneRoleInput.Role.
type CreateKeystoneRoleInput_Role struct {
	Description          *string                `json:"description,omitempty"`
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CreateKeystoneTokenInput defines model for CreateKeystoneTokenInput.
type CreateKeystoneTokenInput struct {
	Auth CreateKeystoneTokenInputAuth `json:"auth"`
}

// CreateKeystoneTokenInputAuth defines model for CreateKeystoneTokenInputAuth.
type CreateKeystoneTokenInputAuth struct {
	Identity CreateKeystoneTokenInputAuthIdentity `json:"identity"`
	Scope    *CreateKeystoneTokenInputAuthScope   `json:"scope,omitempty"`
}

// CreateKeystoneTokenInputAuthIdentity defines model for CreateKeystoneTokenInputAuthIdentity.
type CreateKeystoneTokenInputAuthIdentity struct {
	Methods []string `json:"methods"`
	Token   struct {
		Id *string `json:"id,omitempty"`
	} `json:"token"`
}

// CreateKeystoneTokenInputAuthScope defines model for CreateKeystoneTokenInputAuthScope.
type CreateKeystoneTokenInputAuthScope struct {
	Project *CreateKeystoneTokenInputAuthScopeProject `json:"project,omitempty"`
}

// CreateKeystoneTokenInputAuthScopeProject defines model for CreateKeystoneTokenInputAuthScopeProject.
type CreateKeystoneTokenInputAuthScopeProject struct {
	Domain *struct {
		Id *string `json:"id,omitempty"`
	} `json:"domain,omitempty"`
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// CreateKeystoneUserInput defines model for CreateKeystoneUserInput.
type CreateKeystoneUserInput struct {
	User struct {
		DefaultProjectId string `json:"default_project_id"`
		DomainId         string `json:"domain_id"`
		Enabled          bool   `json:"enabled"`
		Name             string `json:"name"`
		Password         string `json:"password"`
	} `json:"user"`
}

// Endpoint defines model for Endpoint.
type Endpoint struct {
	Id        string `json:"id"`
	Interface string `json:"interface"`
	Region    string `json:"region"`
	Url       string `json:"url"`
}

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code int `json:"code"`

	// Message Error message
	Message string `json:"message"`
}

// KeystoneApplicationCredential defines model for KeystoneApplicationCredential.
type KeystoneApplicationCredential struct {
	AccessRules *[]struct {
		Id      *openapi_types.UUID `json:"id,omitempty"`
		Method  *string             `json:"method,omitempty"`
		Path    *string             `json:"path,omitempty"`
		Service *string             `json:"service,omitempty"`
	} `json:"access_rules,omitempty"`
	Description *string   `json:"description,omitempty"`
	ExpiresAt   time.Time `json:"expires_at"`
	Id          string    `json:"id"`
	Links       *struct {
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`
	Name         string              `json:"name"`
	ProjectId    string              `json:"project_id"`
	Roles        []KeystoneTokenRole `json:"roles"`
	Secret       string              `json:"secret"`
	Unrestricted *bool               `json:"unrestricted,omitempty"`
}

// KeystoneApplicationCredentialResponse defines model for KeystoneApplicationCredentialResponse.
type KeystoneApplicationCredentialResponse struct {
	ApplicationCredential KeystoneApplicationCredential `json:"application_credential"`
}

// KeystoneCatalog defines model for KeystoneCatalog.
type KeystoneCatalog struct {
	Endpoints []KeystoneEndpoint `json:"endpoints"`
	Id        string             `json:"id"`
	Name      string             `json:"name"`
	Type      string             `json:"type"`
}

// KeystoneDomain defines model for KeystoneDomain.
type KeystoneDomain struct {
	Description          string                 `json:"description"`
	Enabled              bool                   `json:"enabled"`
	Id                   string                 `json:"id"`
	Links                KeystoneSelfPagerLinks `json:"links"`
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// KeystoneDomainResponse defines model for KeystoneDomainResponse.
type KeystoneDomainResponse struct {
	Domain KeystoneDomain `json:"domain"`
}

// KeystoneDomainsResponse defines model for KeystoneDomainsResponse.
type KeystoneDomainsResponse struct {
	Domains []KeystoneDomain   `json:"domains"`
	Links   KeystonePagerLinks `json:"links"`
}

// KeystoneEndpoint defines model for KeystoneEndpoint.
type KeystoneEndpoint struct {
	Id        string `json:"id"`
	Interface string `json:"interface"`
	Region    string `json:"region"`
	RegionId  string `json:"region_id"`
	Url       string `json:"url"`
}

// KeystoneGroup defines model for KeystoneGroup.
type KeystoneGroup struct {
	DomainId          string                 `json:"domain_id"`
	Enabled           bool                   `json:"enabled"`
	Id                string                 `json:"id"`
	Links             KeystoneSelfPagerLinks `json:"links"`
	Name              string                 `json:"name"`
	Options           map[string]interface{} `json:"options"`
	PasswordExpiresAt *time.Time             `json:"password_expires_at"`
}

// KeystoneGroupResponse defines model for KeystoneGroupResponse.
type KeystoneGroupResponse struct {
	Group KeystoneGroup `json:"group"`
}

// KeystoneGroupsResponse defines model for KeystoneGroupsResponse.
type KeystoneGroupsResponse struct {
	Groups []KeystoneGroup    `json:"groups"`
	Links  KeystonePagerLinks `json:"links"`
}

// KeystonePagerLinks defines model for KeystonePagerLinks.
type KeystonePagerLinks struct {
	Next     *string `json:"next"`
	Previous *string `json:"previous"`
	Self     string  `json:"self"`
}

// KeystoneProject defines model for KeystoneProject.
type KeystoneProject struct {
	Description          string                 `json:"description"`
	DomainId             string                 `json:"domain_id"`
	Enabled              bool                   `json:"enabled"`
	Id                   string                 `json:"id"`
	IsDomain             bool                   `json:"is_domain"`
	Links                KeystoneSelfPagerLinks `json:"links"`
	Name                 string                 `json:"name"`
	ParentId             string                 `json:"parent_id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// KeystoneProjectResponse defines model for KeystoneProjectResponse.
type KeystoneProjectResponse struct {
	Project KeystoneProject `json:"project"`
}

// KeystoneProjectsResponse defines model for KeystoneProjectsResponse.
type KeystoneProjectsResponse struct {
	Links    KeystonePagerLinks `json:"links"`
	Projects []KeystoneProject  `json:"projects"`
}

// KeystoneRole defines model for KeystoneRole.
type KeystoneRole struct {
	Description          string                 `json:"description"`
	Id                   string                 `json:"id"`
	Links                KeystoneSelfPagerLinks `json:"links"`
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// KeystoneRoleAssignment defines model for KeystoneRoleAssignment.
type KeystoneRoleAssignment struct {
	Group *KeystoneRoleAssignmentGroup `json:"group,omitempty"`
	Links *KeystoneSelfPagerLinks      `json:"links,omitempty"`
	Role  *KeystoneRoleAssignmentRole  `json:"role,omitempty"`
	Scope *KeystoneRoleAssignmentScope `json:"scope,omitempty"`
	User  *KeystoneRoleAssignmentUser  `json:"user,omitempty"`
}

// KeystoneRoleAssignmentDomain defines model for KeystoneRoleAssignmentDomain.
type KeystoneRoleAssignmentDomain struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneRoleAssignmentGroup defines model for KeystoneRoleAssignmentGroup.
type KeystoneRoleAssignmentGroup struct {
	Domain struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	} `json:"domain"`
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneRoleAssignmentProject defines model for KeystoneRoleAssignmentProject.
type KeystoneRoleAssignmentProject struct {
	Domain struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	} `json:"domain"`
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneRoleAssignmentRole defines model for KeystoneRoleAssignmentRole.
type KeystoneRoleAssignmentRole struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneRoleAssignmentScope defines model for KeystoneRoleAssignmentScope.
type KeystoneRoleAssignmentScope struct {
	Domain  *KeystoneRoleAssignmentDomain  `json:"domain,omitempty"`
	Project *KeystoneRoleAssignmentProject `json:"project,omitempty"`
}

// KeystoneRoleAssignmentUser defines model for KeystoneRoleAssignmentUser.
type KeystoneRoleAssignmentUser struct {
	Domain struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	} `json:"domain"`
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneRoleAssignmentsResponse defines model for KeystoneRoleAssignmentsResponse.
type KeystoneRoleAssignmentsResponse struct {
	Links           KeystonePagerLinks       `json:"links"`
	RoleAssignments []KeystoneRoleAssignment `json:"role_assignments"`
}

// KeystoneRoleResponse defines model for KeystoneRoleResponse.
type KeystoneRoleResponse struct {
	Role KeystoneRole `json:"role"`
}

// KeystoneRolesResponse defines model for KeystoneRolesResponse.
type KeystoneRolesResponse struct {
	Links KeystonePagerLinks `json:"links"`
	Roles []KeystoneRole     `json:"roles"`
}

// KeystoneSelfPagerLinks defines model for KeystoneSelfPagerLinks.
type KeystoneSelfPagerLinks struct {
	Self string `json:"self"`
}

// KeystoneToken defines model for KeystoneToken.
type KeystoneToken struct {
	AuditIds  []string              `json:"audit_ids"`
	Catalog   []KeystoneCatalog     `json:"catalog"`
	ExpiresAt time.Time             `json:"expires_at"`
	IsDomain  bool                  `json:"is_domain"`
	IssuedAt  time.Time             `json:"issued_at"`
	Methods   []string              `json:"methods"`
	Project   *KeystoneTokenProject `json:"project,omitempty"`
	Roles     []KeystoneTokenRole   `json:"roles"`
	User      KeystoneTokenUser     `json:"user"`
}

// KeystoneTokenDomain defines model for KeystoneTokenDomain.
type KeystoneTokenDomain struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneTokenProject defines model for KeystoneTokenProject.
type KeystoneTokenProject struct {
	Domain KeystoneTokenDomain `json:"domain"`
	Id     string              `json:"id"`
	Name   string              `json:"name"`
}

// KeystoneTokenResponse defines model for KeystoneTokenResponse.
type KeystoneTokenResponse struct {
	Token KeystoneToken `json:"token"`
}

// KeystoneTokenRole defines model for KeystoneTokenRole.
type KeystoneTokenRole struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// KeystoneTokenUser defines model for KeystoneTokenUser.
type KeystoneTokenUser struct {
	Domain            KeystoneTokenDomain `json:"domain"`
	Id                string              `json:"id"`
	Name              string              `json:"name"`
	PasswordExpiresAt time.Time           `json:"password_expires_at"`
}

// KeystoneUser defines model for KeystoneUser.
type KeystoneUser struct {
	DomainId          string                 `json:"domain_id"`
	Enabled           bool                   `json:"enabled"`
	Id                string                 `json:"id"`
	Links             KeystoneSelfPagerLinks `json:"links"`
	Name              string                 `json:"name"`
	Options           map[string]interface{} `json:"options"`
	PasswordExpiresAt *time.Time             `json:"password_expires_at"`
}

// KeystoneUserResponse defines model for KeystoneUserResponse.
type KeystoneUserResponse struct {
	User KeystoneUser `json:"user"`
}

// KeystoneUsers defines model for KeystoneUsers.
type KeystoneUsers struct {
	Links KeystonePagerLinks `json:"links"`
	Users []KeystoneUser     `json:"users"`
}

// KeystoneVersion defines model for KeystoneVersion.
type KeystoneVersion struct {
	Version KeystoneVersionData `json:"version"`
}

// KeystoneVersionData defines model for KeystoneVersionData.
type KeystoneVersionData struct {
	Id         string                     `json:"id"`
	Links      []KeystoneVersionLink      `json:"links"`
	MediaTypes []KeystoneVersionMediaType `json:"media-types"`
	Status     string                     `json:"status"`
	Updated    time.Time                  `json:"updated"`
}

// KeystoneVersionLink defines model for KeystoneVersionLink.
type KeystoneVersionLink struct {
	Href string `json:"href"`
	Rel  string `json:"rel"`
}

// KeystoneVersionMediaType defines model for KeystoneVersionMediaType.
type KeystoneVersionMediaType struct {
	Base string `json:"base"`
	Type string `json:"type"`
}

// Pubkey defines model for Pubkey.
type Pubkey struct {
	Key string `json:"key"`
}

// Pubkeys defines model for Pubkeys.
type Pubkeys struct {
	Pubkeys []Pubkey `json:"pubkeys"`
}

// UpdateKeystoneDomainInput defines model for UpdateKeystoneDomainInput.
type UpdateKeystoneDomainInput struct {
	Domain UpdateKeystoneDomainInput_Domain `json:"domain"`
}

// UpdateKeystoneDomainInput_Domain defines model for UpdateKeystoneDomainInput.Domain.
type UpdateKeystoneDomainInput_Domain struct {
	Description          *string                `json:"description,omitempty"`
	Enabled              *bool                  `json:"enabled,omitempty"`
	Name                 *string                `json:"name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdateKeystoneProjectInput defines model for UpdateKeystoneProjectInput.
type UpdateKeystoneProjectInput struct {
	Project UpdateKeystoneProjectInput_Project `json:"project"`
}

// UpdateKeystoneProjectInput_Project defines model for UpdateKeystoneProjectInput.Project.
type UpdateKeystoneProjectInput_Project struct {
	Description          *string                `json:"description,omitempty"`
	DomainId             *string                `json:"domain_id,omitempty"`
	Enabled              *bool                  `json:"enabled,omitempty"`
	Name                 *string                `json:"name,omitempty"`
	Tags                 *[]string              `json:"tags,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdateKeystoneRoleInput defines model for UpdateKeystoneRoleInput.
type UpdateKeystoneRoleInput struct {
	Role UpdateKeystoneRoleInput_Role `json:"role"`
}

// UpdateKeystoneRoleInput_Role defines model for UpdateKeystoneRoleInput.Role.
type UpdateKeystoneRoleInput_Role struct {
	Description          *string                `json:"description,omitempty"`
	Name                 *string                `json:"name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// User defines model for User.
type User struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// WebUser defines model for WebUser.
type WebUser struct {
	Catalog  Catalog           `json:"catalog"`
	Projects []KeystoneProject `json:"projects"`
	User     User              `json:"user"`
}

// GetKeystoneDomainsParams defines parameters for GetKeystoneDomains.
type GetKeystoneDomainsParams struct {
	// Name Filters the response by a domain name
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetKeystoneGroupsParams defines parameters for GetKeystoneGroups.
type GetKeystoneGroupsParams struct {
	// Name Filters the response by a group name
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetKeystoneProjectsParams defines parameters for GetKeystoneProjects.
type GetKeystoneProjectsParams struct {
	// Name Filters the response by a project name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Tags Filters the response by tags
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// GetKeystoneRoleAssignmentsParams defines parameters for GetKeystoneRoleAssignments.
type GetKeystoneRoleAssignmentsParams struct {
	// RoleId Filters the response by a role id
	RoleId *string `form:"role.id,omitempty" json:"role.id,omitempty"`

	// UserId Filters the response by a user id
	UserId *string `form:"user.id,omitempty" json:"user.id,omitempty"`

	// ScopeDomainId Filters the response by a domain id
	ScopeDomainId *string `form:"scope.domain.id,omitempty" json:"scope.domain.id,omitempty"`

	// ScopeProjectId Filters the response by a role assignment id
	ScopeProjectId *string `form:"scope.project.id,omitempty" json:"scope.project.id,omitempty"`
}

// GetKeystoneRolesParams defines parameters for GetKeystoneRoles.
type GetKeystoneRolesParams struct {
	// Name Filters the response by a role name
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetKeystoneUsersParams defines parameters for GetKeystoneUsers.
type GetKeystoneUsersParams struct {
	// Name Filters the response by a user name
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetPubkeysParams defines parameters for GetPubkeys.
type GetPubkeysParams struct {
	// Kind kind of public key
	Kind string `form:"kind" json:"kind"`
}

// GetWebUserParams defines parameters for GetWebUser.
type GetWebUserParams struct {
	// ProjectId project id
	ProjectId *string `form:"project_id,omitempty" json:"project_id,omitempty"`
}

// CreateKeystoneTokenJSONRequestBody defines body for CreateKeystoneToken for application/json ContentType.
type CreateKeystoneTokenJSONRequestBody = CreateKeystoneTokenInput

// CreateKeystoneDomainJSONRequestBody defines body for CreateKeystoneDomain for application/json ContentType.
type CreateKeystoneDomainJSONRequestBody = CreateKeystoneDomainInput

// UpdateKeystoneDomainByIDJSONRequestBody defines body for UpdateKeystoneDomainByID for application/json ContentType.
type UpdateKeystoneDomainByIDJSONRequestBody = UpdateKeystoneDomainInput

// CreateKeystoneProjectJSONRequestBody defines body for CreateKeystoneProject for application/json ContentType.
type CreateKeystoneProjectJSONRequestBody = CreateKeystoneProjectInput

// UpdateKeystoneProjectByIDJSONRequestBody defines body for UpdateKeystoneProjectByID for application/json ContentType.
type UpdateKeystoneProjectByIDJSONRequestBody = UpdateKeystoneProjectInput

// CreateKeystoneRoleJSONRequestBody defines body for CreateKeystoneRole for application/json ContentType.
type CreateKeystoneRoleJSONRequestBody = CreateKeystoneRoleInput

// UpdateKeystoneRoleByIDJSONRequestBody defines body for UpdateKeystoneRoleByID for application/json ContentType.
type UpdateKeystoneRoleByIDJSONRequestBody = UpdateKeystoneRoleInput

// CreateKeystoneUserJSONRequestBody defines body for CreateKeystoneUser for application/json ContentType.
type CreateKeystoneUserJSONRequestBody = CreateKeystoneUserInput

// CreateKeystoneApplicationCredentialJSONRequestBody defines body for CreateKeystoneApplicationCredential for application/json ContentType.
type CreateKeystoneApplicationCredentialJSONRequestBody = CreateKeystoneApplicationCredentialInput

// Getter for additional properties for CreateKeystoneDomainInput_Domain. Returns the specified
// element and whether it was found
func (a CreateKeystoneDomainInput_Domain) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateKeystoneDomainInput_Domain
func (a *CreateKeystoneDomainInput_Domain) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateKeystoneDomainInput_Domain to handle AdditionalProperties
func (a *CreateKeystoneDomainInput_Domain) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateKeystoneDomainInput_Domain to handle AdditionalProperties
func (a CreateKeystoneDomainInput_Domain) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateKeystoneProjectInput_Project. Returns the specified
// element and whether it was found
func (a CreateKeystoneProjectInput_Project) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateKeystoneProjectInput_Project
func (a *CreateKeystoneProjectInput_Project) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateKeystoneProjectInput_Project to handle AdditionalProperties
func (a *CreateKeystoneProjectInput_Project) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["domain_id"]; found {
		err = json.Unmarshal(raw, &a.DomainId)
		if err != nil {
			return fmt.Errorf("error reading 'domain_id': %w", err)
		}
		delete(object, "domain_id")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["organization_id"]; found {
		err = json.Unmarshal(raw, &a.OrganizationId)
		if err != nil {
			return fmt.Errorf("error reading 'organization_id': %w", err)
		}
		delete(object, "organization_id")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateKeystoneProjectInput_Project to handle AdditionalProperties
func (a CreateKeystoneProjectInput_Project) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["domain_id"], err = json.Marshal(a.DomainId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'domain_id': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.OrganizationId != nil {
		object["organization_id"], err = json.Marshal(a.OrganizationId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'organization_id': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateKeystoneRoleInput_Role. Returns the specified
// element and whether it was found
func (a CreateKeystoneRoleInput_Role) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateKeystoneRoleInput_Role
func (a *CreateKeystoneRoleInput_Role) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateKeystoneRoleInput_Role to handle AdditionalProperties
func (a *CreateKeystoneRoleInput_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateKeystoneRoleInput_Role to handle AdditionalProperties
func (a CreateKeystoneRoleInput_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for KeystoneDomain. Returns the specified
// element and whether it was found
func (a KeystoneDomain) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for KeystoneDomain
func (a *KeystoneDomain) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for KeystoneDomain to handle AdditionalProperties
func (a *KeystoneDomain) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["links"]; found {
		err = json.Unmarshal(raw, &a.Links)
		if err != nil {
			return fmt.Errorf("error reading 'links': %w", err)
		}
		delete(object, "links")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for KeystoneDomain to handle AdditionalProperties
func (a KeystoneDomain) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["description"], err = json.Marshal(a.Description)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'description': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["links"], err = json.Marshal(a.Links)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'links': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for KeystoneProject. Returns the specified
// element and whether it was found
func (a KeystoneProject) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for KeystoneProject
func (a *KeystoneProject) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for KeystoneProject to handle AdditionalProperties
func (a *KeystoneProject) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["domain_id"]; found {
		err = json.Unmarshal(raw, &a.DomainId)
		if err != nil {
			return fmt.Errorf("error reading 'domain_id': %w", err)
		}
		delete(object, "domain_id")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_domain"]; found {
		err = json.Unmarshal(raw, &a.IsDomain)
		if err != nil {
			return fmt.Errorf("error reading 'is_domain': %w", err)
		}
		delete(object, "is_domain")
	}

	if raw, found := object["links"]; found {
		err = json.Unmarshal(raw, &a.Links)
		if err != nil {
			return fmt.Errorf("error reading 'links': %w", err)
		}
		delete(object, "links")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["parent_id"]; found {
		err = json.Unmarshal(raw, &a.ParentId)
		if err != nil {
			return fmt.Errorf("error reading 'parent_id': %w", err)
		}
		delete(object, "parent_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for KeystoneProject to handle AdditionalProperties
func (a KeystoneProject) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["description"], err = json.Marshal(a.Description)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'description': %w", err)
	}

	object["domain_id"], err = json.Marshal(a.DomainId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'domain_id': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["is_domain"], err = json.Marshal(a.IsDomain)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'is_domain': %w", err)
	}

	object["links"], err = json.Marshal(a.Links)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'links': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["parent_id"], err = json.Marshal(a.ParentId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'parent_id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for KeystoneRole. Returns the specified
// element and whether it was found
func (a KeystoneRole) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for KeystoneRole
func (a *KeystoneRole) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for KeystoneRole to handle AdditionalProperties
func (a *KeystoneRole) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["links"]; found {
		err = json.Unmarshal(raw, &a.Links)
		if err != nil {
			return fmt.Errorf("error reading 'links': %w", err)
		}
		delete(object, "links")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for KeystoneRole to handle AdditionalProperties
func (a KeystoneRole) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["description"], err = json.Marshal(a.Description)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'description': %w", err)
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["links"], err = json.Marshal(a.Links)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'links': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateKeystoneDomainInput_Domain. Returns the specified
// element and whether it was found
func (a UpdateKeystoneDomainInput_Domain) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateKeystoneDomainInput_Domain
func (a *UpdateKeystoneDomainInput_Domain) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateKeystoneDomainInput_Domain to handle AdditionalProperties
func (a *UpdateKeystoneDomainInput_Domain) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateKeystoneDomainInput_Domain to handle AdditionalProperties
func (a UpdateKeystoneDomainInput_Domain) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateKeystoneProjectInput_Project. Returns the specified
// element and whether it was found
func (a UpdateKeystoneProjectInput_Project) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateKeystoneProjectInput_Project
func (a *UpdateKeystoneProjectInput_Project) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateKeystoneProjectInput_Project to handle AdditionalProperties
func (a *UpdateKeystoneProjectInput_Project) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["domain_id"]; found {
		err = json.Unmarshal(raw, &a.DomainId)
		if err != nil {
			return fmt.Errorf("error reading 'domain_id': %w", err)
		}
		delete(object, "domain_id")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateKeystoneProjectInput_Project to handle AdditionalProperties
func (a UpdateKeystoneProjectInput_Project) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.DomainId != nil {
		object["domain_id"], err = json.Marshal(a.DomainId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'domain_id': %w", err)
		}
	}

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateKeystoneRoleInput_Role. Returns the specified
// element and whether it was found
func (a UpdateKeystoneRoleInput_Role) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateKeystoneRoleInput_Role
func (a *UpdateKeystoneRoleInput_Role) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateKeystoneRoleInput_Role to handle AdditionalProperties
func (a *UpdateKeystoneRoleInput_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateKeystoneRoleInput_Role to handle AdditionalProperties
func (a UpdateKeystoneRoleInput_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

var file string
var controller IController

type IController interface {
	GetBaseURL() string
	RequestEditorFn(ctx context.Context, req *http.Request) error
}

var GetKeystoneDomainsName string

var GetKeystoneGroupsName string

var GetKeystoneProjectsName string
var GetKeystoneProjectsTags []string

var GetKeystoneRoleAssignmentsRoleId string
var GetKeystoneRoleAssignmentsUserId string
var GetKeystoneRoleAssignmentsScopeDomainId string
var GetKeystoneRoleAssignmentsScopeProjectId string

var GetKeystoneRolesName string

var GetKeystoneUsersName string

var GetPubkeysKind string

var GetWebUserProjectId string

func init() {
	controller = NewController()

	RootCmd.AddCommand(GetKeystoneVersion)

	RootCmd.AddCommand(CreateKeystoneFederationAuthToken)

	CreateKeystoneToken.PersistentFlags().StringVarP(&file, "file", "f", "", "file path")
	CreateKeystoneToken.MarkPersistentFlagRequired("file")

	RootCmd.AddCommand(CreateKeystoneToken)

	GetKeystoneDomains.PersistentFlags().StringVarP(&GetKeystoneDomainsName, "name", "", "", "Filters the response by a domain name")

	RootCmd.AddCommand(GetKeystoneDomains)

	CreateKeystoneDomain.PersistentFlags().StringVarP(&file, "file", "f", "", "file path")
	CreateKeystoneDomain.MarkPersistentFlagRequired("file")

	RootCmd.AddCommand(CreateKeystoneDomain)

	RootCmd.AddCommand(DeleteKeystoneDomainByID)

	RootCmd.AddCommand(GetKeystoneDomainByID)

	UpdateKeystoneDomainByID.PersistentFlags().StringVarP(&file, "file", "f", "", "file path")
	UpdateKeystoneDomainByID.MarkPersistentFlagRequired("file")

	RootCmd.AddCommand(UpdateKeystoneDomainByID)

	RootCmd.AddCommand(UnassignKeystoneRoleFromUserDomain)

	RootCmd.AddCommand(AssignKeystoneRoleToUserDomain)

	GetKeystoneGroups.PersistentFlags().StringVarP(&GetKeystoneGroupsName, "name", "", "", "Filters the response by a group name")

	RootCmd.AddCommand(GetKeystoneGroups)

	RootCmd.AddCommand(GetKeystoneGroupByID)

	GetKeystoneProjects.PersistentFlags().StringVarP(&GetKeystoneProjectsName, "name", "", "", "Filters the response by a project name")

	GetKeystoneProjects.PersistentFlags().StringSliceVarP(&GetKeystoneProjectsTags, "tags", "", nil, "Filters the response by tags")

	RootCmd.AddCommand(GetKeystoneProjects)

	CreateKeystoneProject.PersistentFlags().StringVarP(&file, "file", "f", "", "file path")
	CreateKeystoneProject.MarkPersistentFlagRequired("file")

	RootCmd.AddCommand(CreateKeystoneProject)

	RootCmd.AddCommand(DeleteKeystoneProjectByID)

	RootCmd.AddCommand(GetKeystoneProjectByID)

	UpdateKeystoneProjectByID.PersistentFlags().StringVarP(&file, "file", "f", "", "file path")
	UpdateKeystoneProjectByID.MarkPersistentFlagRequired("file")

	RootCmd.AddCommand(UpdateKeystoneProjectByID)

	RootCmd.AddCommand(UnassignKeystoneRoleFromGroupProject)

	RootCmd.AddCommand(AssignKeystoneRoleToGroupProject)

	RootCmd.AddCommand(UnassignKeystoneRoleFromUserProject)

	RootCmd.AddCommand(AssignKeystoneRoleToUserProject)

	GetKeystoneRoleAssignments.PersistentFlags().StringVarP(&GetKeystoneRoleAssignmentsRoleId, "roleid", "", "", "Filters the response by a role id")

	GetKeystoneRoleAssignments.PersistentFlags().StringVarP(&GetKeystoneRoleAssignmentsUserId, "userid", "", "", "Filters the response by a user id")

	GetKeystoneRoleAssignments.PersistentFlags().StringVarP(&GetKeystoneRoleAssignmentsScopeDomainId, "scopedomainid", "", "", "Filters the response by a domain id")

	GetKeystoneRoleAssignments.PersistentFlags().StringVarP(&GetKeystoneRoleAssignmentsScopeProjectId, "scopeprojectid", "", "", "Filters the response by a role assignment id")

	RootCmd.AddCommand(GetKeystoneRoleAssignments)

	GetKeystoneRoles.PersistentFlags().StringVarP(&GetKeystoneRolesName, "name", "", "", "Filters the response by a role name")

	RootCmd.AddCommand(GetKeystoneRoles)

	CreateKeystoneRole.PersistentFlags().StringVarP(&file, "file", "f", "", "file path")
	CreateKeystoneRole.MarkPersistentFlagRequired("file")

	RootCmd.AddCommand(CreateKeystoneRole)

	RootCmd.AddCommand(DeleteKeystoneRoleByID)

	RootCmd.AddCommand(GetKeystoneRoleByID)

	UpdateKeystoneRoleByID.PersistentFlags().StringVarP(&file, "file", "f", "", "file path")
	UpdateKeystoneRoleByID.MarkPersistentFlagRequired("file")

	RootCmd.AddCommand(UpdateKeystoneRoleByID)

	GetKeystoneUsers.PersistentFlags().StringVarP(&GetKeystoneUsersName, "name", "", "", "Filters the response by a user name")

	RootCmd.AddCommand(GetKeystoneUsers)

	CreateKeystoneUser.PersistentFlags().StringVarP(&file, "file", "f", "", "file path")
	CreateKeystoneUser.MarkPersistentFlagRequired("file")

	RootCmd.AddCommand(CreateKeystoneUser)

	RootCmd.AddCommand(DeleteKeystoneUserByID)

	RootCmd.AddCommand(GetKeystoneUserByID)

	RootCmd.AddCommand(GetKeystoneUserProjectsByUserID)

	CreateKeystoneApplicationCredential.PersistentFlags().StringVarP(&file, "file", "f", "", "file path")
	CreateKeystoneApplicationCredential.MarkPersistentFlagRequired("file")

	RootCmd.AddCommand(CreateKeystoneApplicationCredential)

	GetPubkeys.PersistentFlags().StringVarP(&GetPubkeysKind, "kind", "", "", "kind of public key")

	GetPubkeys.MarkPersistentFlagRequired("file")

	RootCmd.AddCommand(GetPubkeys)

	GetWebUser.PersistentFlags().StringVarP(&GetWebUserProjectId, "projectid", "", "", "project id")

	RootCmd.AddCommand(GetWebUser)

}

var GetKeystoneVersion = &cobra.Command{
	Use:   "GetKeystoneVersion",
	Short: "GetKeystoneVersion",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.GetKeystoneVersion(ctx)

		fmt.Println(res, err)
	},
}
var CreateKeystoneFederationAuthToken = &cobra.Command{
	Use:   "CreateKeystoneFederationAuthToken <provider> <protocol>",
	Short: "CreateKeystoneFederationAuthToken",
	Args:  cobra.ExactArgs(2),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.CreateKeystoneFederationAuthToken(ctx, args[0], args[1])

		fmt.Println(res, err)
	},
}
var CreateKeystoneToken = &cobra.Command{
	Use:   "CreateKeystoneToken",
	Short: "CreateKeystoneToken",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		bytes, err := os.ReadFile(file)
		if err != nil {
			fmt.Println(err)
		}

		body := CreateKeystoneTokenJSONRequestBody{}
		err = json.Unmarshal(bytes, &body)
		if err != nil {
			fmt.Println(err)
		}

		res, err := client.CreateKeystoneToken(ctx, body)

		fmt.Println(res, err)
	},
}
var GetKeystoneDomains = &cobra.Command{
	Use:   "GetKeystoneDomains",
	Short: "GetKeystoneDomains",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		params := &GetKeystoneDomainsParams{}

		if GetKeystoneDomainsName != "" {
			params.Name = &GetKeystoneDomainsName
		}

		res, err := client.GetKeystoneDomains(ctx, params)

		fmt.Println(res, err)
	},
}
var CreateKeystoneDomain = &cobra.Command{
	Use:   "CreateKeystoneDomain",
	Short: "CreateKeystoneDomain",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		bytes, err := os.ReadFile(file)
		if err != nil {
			fmt.Println(err)
		}

		body := CreateKeystoneDomainJSONRequestBody{}
		err = json.Unmarshal(bytes, &body)
		if err != nil {
			fmt.Println(err)
		}

		res, err := client.CreateKeystoneDomain(ctx, body)

		fmt.Println(res, err)
	},
}
var DeleteKeystoneDomainByID = &cobra.Command{
	Use:   "DeleteKeystoneDomainByID <id>",
	Short: "DeleteKeystoneDomainByID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.DeleteKeystoneDomainByID(ctx, args[0])

		fmt.Println(res, err)
	},
}
var GetKeystoneDomainByID = &cobra.Command{
	Use:   "GetKeystoneDomainByID <id>",
	Short: "GetKeystoneDomainByID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.GetKeystoneDomainByID(ctx, args[0])

		fmt.Println(res, err)
	},
}
var UpdateKeystoneDomainByID = &cobra.Command{
	Use:   "UpdateKeystoneDomainByID <id>",
	Short: "UpdateKeystoneDomainByID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		bytes, err := os.ReadFile(file)
		if err != nil {
			fmt.Println(err)
		}

		body := UpdateKeystoneDomainByIDJSONRequestBody{}
		err = json.Unmarshal(bytes, &body)
		if err != nil {
			fmt.Println(err)
		}

		res, err := client.UpdateKeystoneDomainByID(ctx, args[0], body)

		fmt.Println(res, err)
	},
}
var UnassignKeystoneRoleFromUserDomain = &cobra.Command{
	Use:   "UnassignKeystoneRoleFromUserDomain <id> <userId> <roleId>",
	Short: "UnassignKeystoneRoleFromUserDomain",
	Args:  cobra.ExactArgs(3),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.UnassignKeystoneRoleFromUserDomain(ctx, args[0], args[1], args[2])

		fmt.Println(res, err)
	},
}
var AssignKeystoneRoleToUserDomain = &cobra.Command{
	Use:   "AssignKeystoneRoleToUserDomain <id> <userId> <roleId>",
	Short: "AssignKeystoneRoleToUserDomain",
	Args:  cobra.ExactArgs(3),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.AssignKeystoneRoleToUserDomain(ctx, args[0], args[1], args[2])

		fmt.Println(res, err)
	},
}
var GetKeystoneGroups = &cobra.Command{
	Use:   "GetKeystoneGroups",
	Short: "GetKeystoneGroups",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		params := &GetKeystoneGroupsParams{}

		if GetKeystoneGroupsName != "" {
			params.Name = &GetKeystoneGroupsName
		}

		res, err := client.GetKeystoneGroups(ctx, params)

		fmt.Println(res, err)
	},
}
var GetKeystoneGroupByID = &cobra.Command{
	Use:   "GetKeystoneGroupByID <id>",
	Short: "GetKeystoneGroupByID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.GetKeystoneGroupByID(ctx, args[0])

		fmt.Println(res, err)
	},
}
var GetKeystoneProjects = &cobra.Command{
	Use:   "GetKeystoneProjects",
	Short: "GetKeystoneProjects",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		params := &GetKeystoneProjectsParams{}

		if GetKeystoneProjectsName != "" {
			params.Name = &GetKeystoneProjectsName
		}

		res, err := client.GetKeystoneProjects(ctx, params)

		fmt.Println(res, err)
	},
}
var CreateKeystoneProject = &cobra.Command{
	Use:   "CreateKeystoneProject",
	Short: "CreateKeystoneProject",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		bytes, err := os.ReadFile(file)
		if err != nil {
			fmt.Println(err)
		}

		body := CreateKeystoneProjectJSONRequestBody{}
		err = json.Unmarshal(bytes, &body)
		if err != nil {
			fmt.Println(err)
		}

		res, err := client.CreateKeystoneProject(ctx, body)

		fmt.Println(res, err)
	},
}
var DeleteKeystoneProjectByID = &cobra.Command{
	Use:   "DeleteKeystoneProjectByID <id>",
	Short: "DeleteKeystoneProjectByID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.DeleteKeystoneProjectByID(ctx, args[0])

		fmt.Println(res, err)
	},
}
var GetKeystoneProjectByID = &cobra.Command{
	Use:   "GetKeystoneProjectByID <id>",
	Short: "GetKeystoneProjectByID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.GetKeystoneProjectByID(ctx, args[0])

		fmt.Println(res, err)
	},
}
var UpdateKeystoneProjectByID = &cobra.Command{
	Use:   "UpdateKeystoneProjectByID <id>",
	Short: "UpdateKeystoneProjectByID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		bytes, err := os.ReadFile(file)
		if err != nil {
			fmt.Println(err)
		}

		body := UpdateKeystoneProjectByIDJSONRequestBody{}
		err = json.Unmarshal(bytes, &body)
		if err != nil {
			fmt.Println(err)
		}

		res, err := client.UpdateKeystoneProjectByID(ctx, args[0], body)

		fmt.Println(res, err)
	},
}
var UnassignKeystoneRoleFromGroupProject = &cobra.Command{
	Use:   "UnassignKeystoneRoleFromGroupProject <id> <groupId> <roleId>",
	Short: "UnassignKeystoneRoleFromGroupProject",
	Args:  cobra.ExactArgs(3),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.UnassignKeystoneRoleFromGroupProject(ctx, args[0], args[1], args[2])

		fmt.Println(res, err)
	},
}
var AssignKeystoneRoleToGroupProject = &cobra.Command{
	Use:   "AssignKeystoneRoleToGroupProject <id> <groupId> <roleId>",
	Short: "AssignKeystoneRoleToGroupProject",
	Args:  cobra.ExactArgs(3),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.AssignKeystoneRoleToGroupProject(ctx, args[0], args[1], args[2])

		fmt.Println(res, err)
	},
}
var UnassignKeystoneRoleFromUserProject = &cobra.Command{
	Use:   "UnassignKeystoneRoleFromUserProject <id> <userId> <roleId>",
	Short: "UnassignKeystoneRoleFromUserProject",
	Args:  cobra.ExactArgs(3),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.UnassignKeystoneRoleFromUserProject(ctx, args[0], args[1], args[2])

		fmt.Println(res, err)
	},
}
var AssignKeystoneRoleToUserProject = &cobra.Command{
	Use:   "AssignKeystoneRoleToUserProject <id> <userId> <roleId>",
	Short: "AssignKeystoneRoleToUserProject",
	Args:  cobra.ExactArgs(3),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.AssignKeystoneRoleToUserProject(ctx, args[0], args[1], args[2])

		fmt.Println(res, err)
	},
}
var GetKeystoneRoleAssignments = &cobra.Command{
	Use:   "GetKeystoneRoleAssignments",
	Short: "GetKeystoneRoleAssignments",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		params := &GetKeystoneRoleAssignmentsParams{}

		if GetKeystoneRoleAssignmentsRoleId != "" {
			params.RoleId = &GetKeystoneRoleAssignmentsRoleId
		}

		if GetKeystoneRoleAssignmentsUserId != "" {
			params.UserId = &GetKeystoneRoleAssignmentsUserId
		}

		if GetKeystoneRoleAssignmentsScopeDomainId != "" {
			params.ScopeDomainId = &GetKeystoneRoleAssignmentsScopeDomainId
		}

		if GetKeystoneRoleAssignmentsScopeProjectId != "" {
			params.ScopeProjectId = &GetKeystoneRoleAssignmentsScopeProjectId
		}

		res, err := client.GetKeystoneRoleAssignments(ctx, params)

		fmt.Println(res, err)
	},
}
var GetKeystoneRoles = &cobra.Command{
	Use:   "GetKeystoneRoles",
	Short: "GetKeystoneRoles",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		params := &GetKeystoneRolesParams{}

		if GetKeystoneRolesName != "" {
			params.Name = &GetKeystoneRolesName
		}

		res, err := client.GetKeystoneRoles(ctx, params)

		fmt.Println(res, err)
	},
}
var CreateKeystoneRole = &cobra.Command{
	Use:   "CreateKeystoneRole",
	Short: "CreateKeystoneRole",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		bytes, err := os.ReadFile(file)
		if err != nil {
			fmt.Println(err)
		}

		body := CreateKeystoneRoleJSONRequestBody{}
		err = json.Unmarshal(bytes, &body)
		if err != nil {
			fmt.Println(err)
		}

		res, err := client.CreateKeystoneRole(ctx, body)

		fmt.Println(res, err)
	},
}
var DeleteKeystoneRoleByID = &cobra.Command{
	Use:   "DeleteKeystoneRoleByID <id>",
	Short: "DeleteKeystoneRoleByID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.DeleteKeystoneRoleByID(ctx, args[0])

		fmt.Println(res, err)
	},
}
var GetKeystoneRoleByID = &cobra.Command{
	Use:   "GetKeystoneRoleByID <id>",
	Short: "GetKeystoneRoleByID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.GetKeystoneRoleByID(ctx, args[0])

		fmt.Println(res, err)
	},
}
var UpdateKeystoneRoleByID = &cobra.Command{
	Use:   "UpdateKeystoneRoleByID <id>",
	Short: "UpdateKeystoneRoleByID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		bytes, err := os.ReadFile(file)
		if err != nil {
			fmt.Println(err)
		}

		body := UpdateKeystoneRoleByIDJSONRequestBody{}
		err = json.Unmarshal(bytes, &body)
		if err != nil {
			fmt.Println(err)
		}

		res, err := client.UpdateKeystoneRoleByID(ctx, args[0], body)

		fmt.Println(res, err)
	},
}
var GetKeystoneUsers = &cobra.Command{
	Use:   "GetKeystoneUsers",
	Short: "GetKeystoneUsers",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		params := &GetKeystoneUsersParams{}

		if GetKeystoneUsersName != "" {
			params.Name = &GetKeystoneUsersName
		}

		res, err := client.GetKeystoneUsers(ctx, params)

		fmt.Println(res, err)
	},
}
var CreateKeystoneUser = &cobra.Command{
	Use:   "CreateKeystoneUser",
	Short: "CreateKeystoneUser",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		bytes, err := os.ReadFile(file)
		if err != nil {
			fmt.Println(err)
		}

		body := CreateKeystoneUserJSONRequestBody{}
		err = json.Unmarshal(bytes, &body)
		if err != nil {
			fmt.Println(err)
		}

		res, err := client.CreateKeystoneUser(ctx, body)

		fmt.Println(res, err)
	},
}
var DeleteKeystoneUserByID = &cobra.Command{
	Use:   "DeleteKeystoneUserByID <id>",
	Short: "DeleteKeystoneUserByID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.DeleteKeystoneUserByID(ctx, args[0])

		fmt.Println(res, err)
	},
}
var GetKeystoneUserByID = &cobra.Command{
	Use:   "GetKeystoneUserByID <id>",
	Short: "GetKeystoneUserByID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.GetKeystoneUserByID(ctx, args[0])

		fmt.Println(res, err)
	},
}
var GetKeystoneUserProjectsByUserID = &cobra.Command{
	Use:   "GetKeystoneUserProjectsByUserID <id>",
	Short: "GetKeystoneUserProjectsByUserID",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		res, err := client.GetKeystoneUserProjectsByUserID(ctx, args[0])

		fmt.Println(res, err)
	},
}
var CreateKeystoneApplicationCredential = &cobra.Command{
	Use:   "CreateKeystoneApplicationCredential <userId>",
	Short: "CreateKeystoneApplicationCredential",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		bytes, err := os.ReadFile(file)
		if err != nil {
			fmt.Println(err)
		}

		body := CreateKeystoneApplicationCredentialJSONRequestBody{}
		err = json.Unmarshal(bytes, &body)
		if err != nil {
			fmt.Println(err)
		}

		res, err := client.CreateKeystoneApplicationCredential(ctx, args[0], body)

		fmt.Println(res, err)
	},
}
var GetPubkeys = &cobra.Command{
	Use:   "GetPubkeys",
	Short: "GetPubkeys",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		params := &GetPubkeysParams{}

		params.Kind = GetPubkeysKind

		res, err := client.GetPubkeys(ctx, params)

		fmt.Println(res, err)
	},
}
var GetWebUser = &cobra.Command{
	Use:   "GetWebUser",
	Short: "GetWebUser",
	Args:  cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		client, err := NewClientWithResponses(
			controller.GetBaseURL(),
			WithRequestEditorFn(controller.RequestEditorFn),
		)

		if err != nil {
			fmt.Println(err)
		}

		ctx := context.Background()

		params := &GetWebUserParams{}

		if GetWebUserProjectId != "" {
			params.ProjectId = &GetWebUserProjectId
		}

		res, err := client.GetWebUser(ctx, params)

		fmt.Println(res, err)
	},
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetKeystoneVersion request
	GetKeystoneVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneFederationAuthToken request
	CreateKeystoneFederationAuthToken(ctx context.Context, provider string, protocol string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneTokenWithBody request with any body
	CreateKeystoneTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeystoneToken(ctx context.Context, body CreateKeystoneTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneDomains request
	GetKeystoneDomains(ctx context.Context, params *GetKeystoneDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneDomainWithBody request with any body
	CreateKeystoneDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeystoneDomain(ctx context.Context, body CreateKeystoneDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeystoneDomainByID request
	DeleteKeystoneDomainByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneDomainByID request
	GetKeystoneDomainByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKeystoneDomainByIDWithBody request with any body
	UpdateKeystoneDomainByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKeystoneDomainByID(ctx context.Context, id string, body UpdateKeystoneDomainByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignKeystoneRoleFromUserDomain request
	UnassignKeystoneRoleFromUserDomain(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignKeystoneRoleToUserDomain request
	AssignKeystoneRoleToUserDomain(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneGroups request
	GetKeystoneGroups(ctx context.Context, params *GetKeystoneGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneGroupByID request
	GetKeystoneGroupByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneProjects request
	GetKeystoneProjects(ctx context.Context, params *GetKeystoneProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneProjectWithBody request with any body
	CreateKeystoneProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeystoneProject(ctx context.Context, body CreateKeystoneProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeystoneProjectByID request
	DeleteKeystoneProjectByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneProjectByID request
	GetKeystoneProjectByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKeystoneProjectByIDWithBody request with any body
	UpdateKeystoneProjectByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKeystoneProjectByID(ctx context.Context, id string, body UpdateKeystoneProjectByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignKeystoneRoleFromGroupProject request
	UnassignKeystoneRoleFromGroupProject(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignKeystoneRoleToGroupProject request
	AssignKeystoneRoleToGroupProject(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignKeystoneRoleFromUserProject request
	UnassignKeystoneRoleFromUserProject(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignKeystoneRoleToUserProject request
	AssignKeystoneRoleToUserProject(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneRoleAssignments request
	GetKeystoneRoleAssignments(ctx context.Context, params *GetKeystoneRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneRoles request
	GetKeystoneRoles(ctx context.Context, params *GetKeystoneRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneRoleWithBody request with any body
	CreateKeystoneRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeystoneRole(ctx context.Context, body CreateKeystoneRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeystoneRoleByID request
	DeleteKeystoneRoleByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneRoleByID request
	GetKeystoneRoleByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKeystoneRoleByIDWithBody request with any body
	UpdateKeystoneRoleByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKeystoneRoleByID(ctx context.Context, id string, body UpdateKeystoneRoleByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneUsers request
	GetKeystoneUsers(ctx context.Context, params *GetKeystoneUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneUserWithBody request with any body
	CreateKeystoneUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeystoneUser(ctx context.Context, body CreateKeystoneUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeystoneUserByID request
	DeleteKeystoneUserByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneUserByID request
	GetKeystoneUserByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeystoneUserProjectsByUserID request
	GetKeystoneUserProjectsByUserID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeystoneApplicationCredentialWithBody request with any body
	CreateKeystoneApplicationCredentialWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeystoneApplicationCredential(ctx context.Context, userId string, body CreateKeystoneApplicationCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPubkeys request
	GetPubkeys(ctx context.Context, params *GetPubkeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebUser request
	GetWebUser(ctx context.Context, params *GetWebUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetKeystoneVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneFederationAuthToken(ctx context.Context, provider string, protocol string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneFederationAuthTokenRequest(c.Server, provider, protocol)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneToken(ctx context.Context, body CreateKeystoneTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneDomains(ctx context.Context, params *GetKeystoneDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneDomainsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneDomainRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneDomain(ctx context.Context, body CreateKeystoneDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneDomainRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeystoneDomainByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeystoneDomainByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneDomainByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneDomainByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeystoneDomainByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeystoneDomainByIDRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeystoneDomainByID(ctx context.Context, id string, body UpdateKeystoneDomainByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeystoneDomainByIDRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignKeystoneRoleFromUserDomain(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignKeystoneRoleFromUserDomainRequest(c.Server, id, userId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignKeystoneRoleToUserDomain(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignKeystoneRoleToUserDomainRequest(c.Server, id, userId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneGroups(ctx context.Context, params *GetKeystoneGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneGroupByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneGroupByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneProjects(ctx context.Context, params *GetKeystoneProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneProject(ctx context.Context, body CreateKeystoneProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeystoneProjectByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeystoneProjectByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneProjectByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneProjectByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeystoneProjectByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeystoneProjectByIDRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeystoneProjectByID(ctx context.Context, id string, body UpdateKeystoneProjectByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeystoneProjectByIDRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignKeystoneRoleFromGroupProject(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignKeystoneRoleFromGroupProjectRequest(c.Server, id, groupId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignKeystoneRoleToGroupProject(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignKeystoneRoleToGroupProjectRequest(c.Server, id, groupId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignKeystoneRoleFromUserProject(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignKeystoneRoleFromUserProjectRequest(c.Server, id, userId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignKeystoneRoleToUserProject(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignKeystoneRoleToUserProjectRequest(c.Server, id, userId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneRoleAssignments(ctx context.Context, params *GetKeystoneRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneRoleAssignmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneRoles(ctx context.Context, params *GetKeystoneRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneRole(ctx context.Context, body CreateKeystoneRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeystoneRoleByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeystoneRoleByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneRoleByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneRoleByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeystoneRoleByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeystoneRoleByIDRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeystoneRoleByID(ctx context.Context, id string, body UpdateKeystoneRoleByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeystoneRoleByIDRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneUsers(ctx context.Context, params *GetKeystoneUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneUser(ctx context.Context, body CreateKeystoneUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeystoneUserByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeystoneUserByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneUserByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneUserByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeystoneUserProjectsByUserID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeystoneUserProjectsByUserIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneApplicationCredentialWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneApplicationCredentialRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeystoneApplicationCredential(ctx context.Context, userId string, body CreateKeystoneApplicationCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeystoneApplicationCredentialRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPubkeys(ctx context.Context, params *GetPubkeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPubkeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebUser(ctx context.Context, params *GetWebUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetKeystoneVersionRequest generates requests for GetKeystoneVersion
func NewGetKeystoneVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneFederationAuthTokenRequest generates requests for CreateKeystoneFederationAuthToken
func NewCreateKeystoneFederationAuthTokenRequest(server string, provider string, protocol string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "protocol", runtime.ParamLocationPath, protocol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/OS-FEDERATION/identity_providers/%s/protocols/%s/auth", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneTokenRequest calls the generic CreateKeystoneToken builder with application/json body
func NewCreateKeystoneTokenRequest(server string, body CreateKeystoneTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeystoneTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeystoneTokenRequestWithBody generates requests for CreateKeystoneToken with any type of body
func NewCreateKeystoneTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/auth/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKeystoneDomainsRequest generates requests for GetKeystoneDomains
func NewGetKeystoneDomainsRequest(server string, params *GetKeystoneDomainsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneDomainRequest calls the generic CreateKeystoneDomain builder with application/json body
func NewCreateKeystoneDomainRequest(server string, body CreateKeystoneDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeystoneDomainRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeystoneDomainRequestWithBody generates requests for CreateKeystoneDomain with any type of body
func NewCreateKeystoneDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeystoneDomainByIDRequest generates requests for DeleteKeystoneDomainByID
func NewDeleteKeystoneDomainByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneDomainByIDRequest generates requests for GetKeystoneDomainByID
func NewGetKeystoneDomainByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKeystoneDomainByIDRequest calls the generic UpdateKeystoneDomainByID builder with application/json body
func NewUpdateKeystoneDomainByIDRequest(server string, id string, body UpdateKeystoneDomainByIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKeystoneDomainByIDRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateKeystoneDomainByIDRequestWithBody generates requests for UpdateKeystoneDomainByID with any type of body
func NewUpdateKeystoneDomainByIDRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignKeystoneRoleFromUserDomainRequest generates requests for UnassignKeystoneRoleFromUserDomain
func NewUnassignKeystoneRoleFromUserDomainRequest(server string, id string, userId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains/%s/users/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignKeystoneRoleToUserDomainRequest generates requests for AssignKeystoneRoleToUserDomain
func NewAssignKeystoneRoleToUserDomainRequest(server string, id string, userId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/domains/%s/users/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneGroupsRequest generates requests for GetKeystoneGroups
func NewGetKeystoneGroupsRequest(server string, params *GetKeystoneGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneGroupByIDRequest generates requests for GetKeystoneGroupByID
func NewGetKeystoneGroupByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneProjectsRequest generates requests for GetKeystoneProjects
func NewGetKeystoneProjectsRequest(server string, params *GetKeystoneProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneProjectRequest calls the generic CreateKeystoneProject builder with application/json body
func NewCreateKeystoneProjectRequest(server string, body CreateKeystoneProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeystoneProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeystoneProjectRequestWithBody generates requests for CreateKeystoneProject with any type of body
func NewCreateKeystoneProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeystoneProjectByIDRequest generates requests for DeleteKeystoneProjectByID
func NewDeleteKeystoneProjectByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneProjectByIDRequest generates requests for GetKeystoneProjectByID
func NewGetKeystoneProjectByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKeystoneProjectByIDRequest calls the generic UpdateKeystoneProjectByID builder with application/json body
func NewUpdateKeystoneProjectByIDRequest(server string, id string, body UpdateKeystoneProjectByIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKeystoneProjectByIDRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateKeystoneProjectByIDRequestWithBody generates requests for UpdateKeystoneProjectByID with any type of body
func NewUpdateKeystoneProjectByIDRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignKeystoneRoleFromGroupProjectRequest generates requests for UnassignKeystoneRoleFromGroupProject
func NewUnassignKeystoneRoleFromGroupProjectRequest(server string, id string, groupId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s/groups/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignKeystoneRoleToGroupProjectRequest generates requests for AssignKeystoneRoleToGroupProject
func NewAssignKeystoneRoleToGroupProjectRequest(server string, id string, groupId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s/groups/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnassignKeystoneRoleFromUserProjectRequest generates requests for UnassignKeystoneRoleFromUserProject
func NewUnassignKeystoneRoleFromUserProjectRequest(server string, id string, userId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s/users/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignKeystoneRoleToUserProjectRequest generates requests for AssignKeystoneRoleToUserProject
func NewAssignKeystoneRoleToUserProjectRequest(server string, id string, userId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/projects/%s/users/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneRoleAssignmentsRequest generates requests for GetKeystoneRoleAssignments
func NewGetKeystoneRoleAssignmentsRequest(server string, params *GetKeystoneRoleAssignmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/role_assignments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RoleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role.id", runtime.ParamLocationQuery, *params.RoleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user.id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScopeDomainId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope.domain.id", runtime.ParamLocationQuery, *params.ScopeDomainId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScopeProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope.project.id", runtime.ParamLocationQuery, *params.ScopeProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneRolesRequest generates requests for GetKeystoneRoles
func NewGetKeystoneRolesRequest(server string, params *GetKeystoneRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneRoleRequest calls the generic CreateKeystoneRole builder with application/json body
func NewCreateKeystoneRoleRequest(server string, body CreateKeystoneRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeystoneRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeystoneRoleRequestWithBody generates requests for CreateKeystoneRole with any type of body
func NewCreateKeystoneRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeystoneRoleByIDRequest generates requests for DeleteKeystoneRoleByID
func NewDeleteKeystoneRoleByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneRoleByIDRequest generates requests for GetKeystoneRoleByID
func NewGetKeystoneRoleByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKeystoneRoleByIDRequest calls the generic UpdateKeystoneRoleByID builder with application/json body
func NewUpdateKeystoneRoleByIDRequest(server string, id string, body UpdateKeystoneRoleByIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKeystoneRoleByIDRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateKeystoneRoleByIDRequestWithBody generates requests for UpdateKeystoneRoleByID with any type of body
func NewUpdateKeystoneRoleByIDRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKeystoneUsersRequest generates requests for GetKeystoneUsers
func NewGetKeystoneUsersRequest(server string, params *GetKeystoneUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneUserRequest calls the generic CreateKeystoneUser builder with application/json body
func NewCreateKeystoneUserRequest(server string, body CreateKeystoneUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeystoneUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeystoneUserRequestWithBody generates requests for CreateKeystoneUser with any type of body
func NewCreateKeystoneUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeystoneUserByIDRequest generates requests for DeleteKeystoneUserByID
func NewDeleteKeystoneUserByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneUserByIDRequest generates requests for GetKeystoneUserByID
func NewGetKeystoneUserByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeystoneUserProjectsByUserIDRequest generates requests for GetKeystoneUserProjectsByUserID
func NewGetKeystoneUserProjectsByUserIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/users/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeystoneApplicationCredentialRequest calls the generic CreateKeystoneApplicationCredential builder with application/json body
func NewCreateKeystoneApplicationCredentialRequest(server string, userId string, body CreateKeystoneApplicationCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeystoneApplicationCredentialRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewCreateKeystoneApplicationCredentialRequestWithBody generates requests for CreateKeystoneApplicationCredential with any type of body
func NewCreateKeystoneApplicationCredentialRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keystone/v3/users/%s/application_credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPubkeysRequest generates requests for GetPubkeys
func NewGetPubkeysRequest(server string, params *GetPubkeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pubkeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, params.Kind); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebUserRequest generates requests for GetWebUser
func NewGetWebUserRequest(server string, params *GetWebUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/web/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetKeystoneVersionWithResponse request
	GetKeystoneVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeystoneVersionResponse, error)

	// CreateKeystoneFederationAuthTokenWithResponse request
	CreateKeystoneFederationAuthTokenWithResponse(ctx context.Context, provider string, protocol string, reqEditors ...RequestEditorFn) (*CreateKeystoneFederationAuthTokenResponse, error)

	// CreateKeystoneTokenWithBodyWithResponse request with any body
	CreateKeystoneTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneTokenResponse, error)

	CreateKeystoneTokenWithResponse(ctx context.Context, body CreateKeystoneTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneTokenResponse, error)

	// GetKeystoneDomainsWithResponse request
	GetKeystoneDomainsWithResponse(ctx context.Context, params *GetKeystoneDomainsParams, reqEditors ...RequestEditorFn) (*GetKeystoneDomainsResponse, error)

	// CreateKeystoneDomainWithBodyWithResponse request with any body
	CreateKeystoneDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneDomainResponse, error)

	CreateKeystoneDomainWithResponse(ctx context.Context, body CreateKeystoneDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneDomainResponse, error)

	// DeleteKeystoneDomainByIDWithResponse request
	DeleteKeystoneDomainByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneDomainByIDResponse, error)

	// GetKeystoneDomainByIDWithResponse request
	GetKeystoneDomainByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneDomainByIDResponse, error)

	// UpdateKeystoneDomainByIDWithBodyWithResponse request with any body
	UpdateKeystoneDomainByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeystoneDomainByIDResponse, error)

	UpdateKeystoneDomainByIDWithResponse(ctx context.Context, id string, body UpdateKeystoneDomainByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeystoneDomainByIDResponse, error)

	// UnassignKeystoneRoleFromUserDomainWithResponse request
	UnassignKeystoneRoleFromUserDomainWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*UnassignKeystoneRoleFromUserDomainResponse, error)

	// AssignKeystoneRoleToUserDomainWithResponse request
	AssignKeystoneRoleToUserDomainWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*AssignKeystoneRoleToUserDomainResponse, error)

	// GetKeystoneGroupsWithResponse request
	GetKeystoneGroupsWithResponse(ctx context.Context, params *GetKeystoneGroupsParams, reqEditors ...RequestEditorFn) (*GetKeystoneGroupsResponse, error)

	// GetKeystoneGroupByIDWithResponse request
	GetKeystoneGroupByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneGroupByIDResponse, error)

	// GetKeystoneProjectsWithResponse request
	GetKeystoneProjectsWithResponse(ctx context.Context, params *GetKeystoneProjectsParams, reqEditors ...RequestEditorFn) (*GetKeystoneProjectsResponse, error)

	// CreateKeystoneProjectWithBodyWithResponse request with any body
	CreateKeystoneProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneProjectResponse, error)

	CreateKeystoneProjectWithResponse(ctx context.Context, body CreateKeystoneProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneProjectResponse, error)

	// DeleteKeystoneProjectByIDWithResponse request
	DeleteKeystoneProjectByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneProjectByIDResponse, error)

	// GetKeystoneProjectByIDWithResponse request
	GetKeystoneProjectByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneProjectByIDResponse, error)

	// UpdateKeystoneProjectByIDWithBodyWithResponse request with any body
	UpdateKeystoneProjectByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeystoneProjectByIDResponse, error)

	UpdateKeystoneProjectByIDWithResponse(ctx context.Context, id string, body UpdateKeystoneProjectByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeystoneProjectByIDResponse, error)

	// UnassignKeystoneRoleFromGroupProjectWithResponse request
	UnassignKeystoneRoleFromGroupProjectWithResponse(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*UnassignKeystoneRoleFromGroupProjectResponse, error)

	// AssignKeystoneRoleToGroupProjectWithResponse request
	AssignKeystoneRoleToGroupProjectWithResponse(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*AssignKeystoneRoleToGroupProjectResponse, error)

	// UnassignKeystoneRoleFromUserProjectWithResponse request
	UnassignKeystoneRoleFromUserProjectWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*UnassignKeystoneRoleFromUserProjectResponse, error)

	// AssignKeystoneRoleToUserProjectWithResponse request
	AssignKeystoneRoleToUserProjectWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*AssignKeystoneRoleToUserProjectResponse, error)

	// GetKeystoneRoleAssignmentsWithResponse request
	GetKeystoneRoleAssignmentsWithResponse(ctx context.Context, params *GetKeystoneRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*GetKeystoneRoleAssignmentsResponse, error)

	// GetKeystoneRolesWithResponse request
	GetKeystoneRolesWithResponse(ctx context.Context, params *GetKeystoneRolesParams, reqEditors ...RequestEditorFn) (*GetKeystoneRolesResponse, error)

	// CreateKeystoneRoleWithBodyWithResponse request with any body
	CreateKeystoneRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneRoleResponse, error)

	CreateKeystoneRoleWithResponse(ctx context.Context, body CreateKeystoneRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneRoleResponse, error)

	// DeleteKeystoneRoleByIDWithResponse request
	DeleteKeystoneRoleByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneRoleByIDResponse, error)

	// GetKeystoneRoleByIDWithResponse request
	GetKeystoneRoleByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneRoleByIDResponse, error)

	// UpdateKeystoneRoleByIDWithBodyWithResponse request with any body
	UpdateKeystoneRoleByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeystoneRoleByIDResponse, error)

	UpdateKeystoneRoleByIDWithResponse(ctx context.Context, id string, body UpdateKeystoneRoleByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeystoneRoleByIDResponse, error)

	// GetKeystoneUsersWithResponse request
	GetKeystoneUsersWithResponse(ctx context.Context, params *GetKeystoneUsersParams, reqEditors ...RequestEditorFn) (*GetKeystoneUsersResponse, error)

	// CreateKeystoneUserWithBodyWithResponse request with any body
	CreateKeystoneUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneUserResponse, error)

	CreateKeystoneUserWithResponse(ctx context.Context, body CreateKeystoneUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneUserResponse, error)

	// DeleteKeystoneUserByIDWithResponse request
	DeleteKeystoneUserByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneUserByIDResponse, error)

	// GetKeystoneUserByIDWithResponse request
	GetKeystoneUserByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneUserByIDResponse, error)

	// GetKeystoneUserProjectsByUserIDWithResponse request
	GetKeystoneUserProjectsByUserIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneUserProjectsByUserIDResponse, error)

	// CreateKeystoneApplicationCredentialWithBodyWithResponse request with any body
	CreateKeystoneApplicationCredentialWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneApplicationCredentialResponse, error)

	CreateKeystoneApplicationCredentialWithResponse(ctx context.Context, userId string, body CreateKeystoneApplicationCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneApplicationCredentialResponse, error)

	// GetPubkeysWithResponse request
	GetPubkeysWithResponse(ctx context.Context, params *GetPubkeysParams, reqEditors ...RequestEditorFn) (*GetPubkeysResponse, error)

	// GetWebUserWithResponse request
	GetWebUserWithResponse(ctx context.Context, params *GetWebUserParams, reqEditors ...RequestEditorFn) (*GetWebUserResponse, error)
}

type GetKeystoneVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneVersion
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneFederationAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneTokenResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneFederationAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneFederationAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneTokenResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneDomainsResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneDomainResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeystoneDomainByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteKeystoneDomainByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeystoneDomainByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneDomainByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneDomainResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneDomainByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneDomainByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKeystoneDomainByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneDomainResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateKeystoneDomainByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeystoneDomainByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignKeystoneRoleFromUserDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UnassignKeystoneRoleFromUserDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignKeystoneRoleFromUserDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignKeystoneRoleToUserDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AssignKeystoneRoleToUserDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignKeystoneRoleToUserDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneGroupsResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneGroupByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneGroupResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneGroupByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneGroupByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneProjectsResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneProjectResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeystoneProjectByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteKeystoneProjectByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeystoneProjectByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneProjectByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneProjectResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneProjectByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneProjectByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKeystoneProjectByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneProjectResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateKeystoneProjectByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeystoneProjectByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignKeystoneRoleFromGroupProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UnassignKeystoneRoleFromGroupProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignKeystoneRoleFromGroupProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignKeystoneRoleToGroupProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AssignKeystoneRoleToGroupProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignKeystoneRoleToGroupProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignKeystoneRoleFromUserProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UnassignKeystoneRoleFromUserProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignKeystoneRoleFromUserProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignKeystoneRoleToUserProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AssignKeystoneRoleToUserProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignKeystoneRoleToUserProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneRoleAssignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneRoleAssignmentsResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneRoleAssignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneRoleAssignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneRolesResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneRoleResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeystoneRoleByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteKeystoneRoleByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeystoneRoleByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneRoleByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneRoleResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneRoleByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneRoleByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKeystoneRoleByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneRoleResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateKeystoneRoleByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeystoneRoleByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneUsers
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneUser
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeystoneUserByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteKeystoneUserByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeystoneUserByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneUserByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneUser
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneUserByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneUserByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeystoneUserProjectsByUserIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneUserResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetKeystoneUserProjectsByUserIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeystoneUserProjectsByUserIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeystoneApplicationCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeystoneApplicationCredentialResponse
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeystoneApplicationCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeystoneApplicationCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPubkeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pubkeys
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPubkeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPubkeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebUser
	JSON4XX      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetWebUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetKeystoneVersionWithResponse request returning *GetKeystoneVersionResponse
func (c *ClientWithResponses) GetKeystoneVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeystoneVersionResponse, error) {
	rsp, err := c.GetKeystoneVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneVersionResponse(rsp)
}

// CreateKeystoneFederationAuthTokenWithResponse request returning *CreateKeystoneFederationAuthTokenResponse
func (c *ClientWithResponses) CreateKeystoneFederationAuthTokenWithResponse(ctx context.Context, provider string, protocol string, reqEditors ...RequestEditorFn) (*CreateKeystoneFederationAuthTokenResponse, error) {
	rsp, err := c.CreateKeystoneFederationAuthToken(ctx, provider, protocol, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneFederationAuthTokenResponse(rsp)
}

// CreateKeystoneTokenWithBodyWithResponse request with arbitrary body returning *CreateKeystoneTokenResponse
func (c *ClientWithResponses) CreateKeystoneTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneTokenResponse, error) {
	rsp, err := c.CreateKeystoneTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateKeystoneTokenWithResponse(ctx context.Context, body CreateKeystoneTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneTokenResponse, error) {
	rsp, err := c.CreateKeystoneToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneTokenResponse(rsp)
}

// GetKeystoneDomainsWithResponse request returning *GetKeystoneDomainsResponse
func (c *ClientWithResponses) GetKeystoneDomainsWithResponse(ctx context.Context, params *GetKeystoneDomainsParams, reqEditors ...RequestEditorFn) (*GetKeystoneDomainsResponse, error) {
	rsp, err := c.GetKeystoneDomains(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneDomainsResponse(rsp)
}

// CreateKeystoneDomainWithBodyWithResponse request with arbitrary body returning *CreateKeystoneDomainResponse
func (c *ClientWithResponses) CreateKeystoneDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneDomainResponse, error) {
	rsp, err := c.CreateKeystoneDomainWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneDomainResponse(rsp)
}

func (c *ClientWithResponses) CreateKeystoneDomainWithResponse(ctx context.Context, body CreateKeystoneDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneDomainResponse, error) {
	rsp, err := c.CreateKeystoneDomain(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneDomainResponse(rsp)
}

// DeleteKeystoneDomainByIDWithResponse request returning *DeleteKeystoneDomainByIDResponse
func (c *ClientWithResponses) DeleteKeystoneDomainByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneDomainByIDResponse, error) {
	rsp, err := c.DeleteKeystoneDomainByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeystoneDomainByIDResponse(rsp)
}

// GetKeystoneDomainByIDWithResponse request returning *GetKeystoneDomainByIDResponse
func (c *ClientWithResponses) GetKeystoneDomainByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneDomainByIDResponse, error) {
	rsp, err := c.GetKeystoneDomainByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneDomainByIDResponse(rsp)
}

// UpdateKeystoneDomainByIDWithBodyWithResponse request with arbitrary body returning *UpdateKeystoneDomainByIDResponse
func (c *ClientWithResponses) UpdateKeystoneDomainByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeystoneDomainByIDResponse, error) {
	rsp, err := c.UpdateKeystoneDomainByIDWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeystoneDomainByIDResponse(rsp)
}

func (c *ClientWithResponses) UpdateKeystoneDomainByIDWithResponse(ctx context.Context, id string, body UpdateKeystoneDomainByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeystoneDomainByIDResponse, error) {
	rsp, err := c.UpdateKeystoneDomainByID(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeystoneDomainByIDResponse(rsp)
}

// UnassignKeystoneRoleFromUserDomainWithResponse request returning *UnassignKeystoneRoleFromUserDomainResponse
func (c *ClientWithResponses) UnassignKeystoneRoleFromUserDomainWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*UnassignKeystoneRoleFromUserDomainResponse, error) {
	rsp, err := c.UnassignKeystoneRoleFromUserDomain(ctx, id, userId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignKeystoneRoleFromUserDomainResponse(rsp)
}

// AssignKeystoneRoleToUserDomainWithResponse request returning *AssignKeystoneRoleToUserDomainResponse
func (c *ClientWithResponses) AssignKeystoneRoleToUserDomainWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*AssignKeystoneRoleToUserDomainResponse, error) {
	rsp, err := c.AssignKeystoneRoleToUserDomain(ctx, id, userId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignKeystoneRoleToUserDomainResponse(rsp)
}

// GetKeystoneGroupsWithResponse request returning *GetKeystoneGroupsResponse
func (c *ClientWithResponses) GetKeystoneGroupsWithResponse(ctx context.Context, params *GetKeystoneGroupsParams, reqEditors ...RequestEditorFn) (*GetKeystoneGroupsResponse, error) {
	rsp, err := c.GetKeystoneGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneGroupsResponse(rsp)
}

// GetKeystoneGroupByIDWithResponse request returning *GetKeystoneGroupByIDResponse
func (c *ClientWithResponses) GetKeystoneGroupByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneGroupByIDResponse, error) {
	rsp, err := c.GetKeystoneGroupByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneGroupByIDResponse(rsp)
}

// GetKeystoneProjectsWithResponse request returning *GetKeystoneProjectsResponse
func (c *ClientWithResponses) GetKeystoneProjectsWithResponse(ctx context.Context, params *GetKeystoneProjectsParams, reqEditors ...RequestEditorFn) (*GetKeystoneProjectsResponse, error) {
	rsp, err := c.GetKeystoneProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneProjectsResponse(rsp)
}

// CreateKeystoneProjectWithBodyWithResponse request with arbitrary body returning *CreateKeystoneProjectResponse
func (c *ClientWithResponses) CreateKeystoneProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneProjectResponse, error) {
	rsp, err := c.CreateKeystoneProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateKeystoneProjectWithResponse(ctx context.Context, body CreateKeystoneProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneProjectResponse, error) {
	rsp, err := c.CreateKeystoneProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneProjectResponse(rsp)
}

// DeleteKeystoneProjectByIDWithResponse request returning *DeleteKeystoneProjectByIDResponse
func (c *ClientWithResponses) DeleteKeystoneProjectByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneProjectByIDResponse, error) {
	rsp, err := c.DeleteKeystoneProjectByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeystoneProjectByIDResponse(rsp)
}

// GetKeystoneProjectByIDWithResponse request returning *GetKeystoneProjectByIDResponse
func (c *ClientWithResponses) GetKeystoneProjectByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneProjectByIDResponse, error) {
	rsp, err := c.GetKeystoneProjectByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneProjectByIDResponse(rsp)
}

// UpdateKeystoneProjectByIDWithBodyWithResponse request with arbitrary body returning *UpdateKeystoneProjectByIDResponse
func (c *ClientWithResponses) UpdateKeystoneProjectByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeystoneProjectByIDResponse, error) {
	rsp, err := c.UpdateKeystoneProjectByIDWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeystoneProjectByIDResponse(rsp)
}

func (c *ClientWithResponses) UpdateKeystoneProjectByIDWithResponse(ctx context.Context, id string, body UpdateKeystoneProjectByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeystoneProjectByIDResponse, error) {
	rsp, err := c.UpdateKeystoneProjectByID(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeystoneProjectByIDResponse(rsp)
}

// UnassignKeystoneRoleFromGroupProjectWithResponse request returning *UnassignKeystoneRoleFromGroupProjectResponse
func (c *ClientWithResponses) UnassignKeystoneRoleFromGroupProjectWithResponse(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*UnassignKeystoneRoleFromGroupProjectResponse, error) {
	rsp, err := c.UnassignKeystoneRoleFromGroupProject(ctx, id, groupId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignKeystoneRoleFromGroupProjectResponse(rsp)
}

// AssignKeystoneRoleToGroupProjectWithResponse request returning *AssignKeystoneRoleToGroupProjectResponse
func (c *ClientWithResponses) AssignKeystoneRoleToGroupProjectWithResponse(ctx context.Context, id string, groupId string, roleId string, reqEditors ...RequestEditorFn) (*AssignKeystoneRoleToGroupProjectResponse, error) {
	rsp, err := c.AssignKeystoneRoleToGroupProject(ctx, id, groupId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignKeystoneRoleToGroupProjectResponse(rsp)
}

// UnassignKeystoneRoleFromUserProjectWithResponse request returning *UnassignKeystoneRoleFromUserProjectResponse
func (c *ClientWithResponses) UnassignKeystoneRoleFromUserProjectWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*UnassignKeystoneRoleFromUserProjectResponse, error) {
	rsp, err := c.UnassignKeystoneRoleFromUserProject(ctx, id, userId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignKeystoneRoleFromUserProjectResponse(rsp)
}

// AssignKeystoneRoleToUserProjectWithResponse request returning *AssignKeystoneRoleToUserProjectResponse
func (c *ClientWithResponses) AssignKeystoneRoleToUserProjectWithResponse(ctx context.Context, id string, userId string, roleId string, reqEditors ...RequestEditorFn) (*AssignKeystoneRoleToUserProjectResponse, error) {
	rsp, err := c.AssignKeystoneRoleToUserProject(ctx, id, userId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignKeystoneRoleToUserProjectResponse(rsp)
}

// GetKeystoneRoleAssignmentsWithResponse request returning *GetKeystoneRoleAssignmentsResponse
func (c *ClientWithResponses) GetKeystoneRoleAssignmentsWithResponse(ctx context.Context, params *GetKeystoneRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*GetKeystoneRoleAssignmentsResponse, error) {
	rsp, err := c.GetKeystoneRoleAssignments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneRoleAssignmentsResponse(rsp)
}

// GetKeystoneRolesWithResponse request returning *GetKeystoneRolesResponse
func (c *ClientWithResponses) GetKeystoneRolesWithResponse(ctx context.Context, params *GetKeystoneRolesParams, reqEditors ...RequestEditorFn) (*GetKeystoneRolesResponse, error) {
	rsp, err := c.GetKeystoneRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneRolesResponse(rsp)
}

// CreateKeystoneRoleWithBodyWithResponse request with arbitrary body returning *CreateKeystoneRoleResponse
func (c *ClientWithResponses) CreateKeystoneRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneRoleResponse, error) {
	rsp, err := c.CreateKeystoneRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateKeystoneRoleWithResponse(ctx context.Context, body CreateKeystoneRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneRoleResponse, error) {
	rsp, err := c.CreateKeystoneRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneRoleResponse(rsp)
}

// DeleteKeystoneRoleByIDWithResponse request returning *DeleteKeystoneRoleByIDResponse
func (c *ClientWithResponses) DeleteKeystoneRoleByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneRoleByIDResponse, error) {
	rsp, err := c.DeleteKeystoneRoleByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeystoneRoleByIDResponse(rsp)
}

// GetKeystoneRoleByIDWithResponse request returning *GetKeystoneRoleByIDResponse
func (c *ClientWithResponses) GetKeystoneRoleByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneRoleByIDResponse, error) {
	rsp, err := c.GetKeystoneRoleByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneRoleByIDResponse(rsp)
}

// UpdateKeystoneRoleByIDWithBodyWithResponse request with arbitrary body returning *UpdateKeystoneRoleByIDResponse
func (c *ClientWithResponses) UpdateKeystoneRoleByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeystoneRoleByIDResponse, error) {
	rsp, err := c.UpdateKeystoneRoleByIDWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeystoneRoleByIDResponse(rsp)
}

func (c *ClientWithResponses) UpdateKeystoneRoleByIDWithResponse(ctx context.Context, id string, body UpdateKeystoneRoleByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeystoneRoleByIDResponse, error) {
	rsp, err := c.UpdateKeystoneRoleByID(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeystoneRoleByIDResponse(rsp)
}

// GetKeystoneUsersWithResponse request returning *GetKeystoneUsersResponse
func (c *ClientWithResponses) GetKeystoneUsersWithResponse(ctx context.Context, params *GetKeystoneUsersParams, reqEditors ...RequestEditorFn) (*GetKeystoneUsersResponse, error) {
	rsp, err := c.GetKeystoneUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneUsersResponse(rsp)
}

// CreateKeystoneUserWithBodyWithResponse request with arbitrary body returning *CreateKeystoneUserResponse
func (c *ClientWithResponses) CreateKeystoneUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneUserResponse, error) {
	rsp, err := c.CreateKeystoneUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneUserResponse(rsp)
}

func (c *ClientWithResponses) CreateKeystoneUserWithResponse(ctx context.Context, body CreateKeystoneUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneUserResponse, error) {
	rsp, err := c.CreateKeystoneUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneUserResponse(rsp)
}

// DeleteKeystoneUserByIDWithResponse request returning *DeleteKeystoneUserByIDResponse
func (c *ClientWithResponses) DeleteKeystoneUserByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeystoneUserByIDResponse, error) {
	rsp, err := c.DeleteKeystoneUserByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeystoneUserByIDResponse(rsp)
}

// GetKeystoneUserByIDWithResponse request returning *GetKeystoneUserByIDResponse
func (c *ClientWithResponses) GetKeystoneUserByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneUserByIDResponse, error) {
	rsp, err := c.GetKeystoneUserByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneUserByIDResponse(rsp)
}

// GetKeystoneUserProjectsByUserIDWithResponse request returning *GetKeystoneUserProjectsByUserIDResponse
func (c *ClientWithResponses) GetKeystoneUserProjectsByUserIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeystoneUserProjectsByUserIDResponse, error) {
	rsp, err := c.GetKeystoneUserProjectsByUserID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeystoneUserProjectsByUserIDResponse(rsp)
}

// CreateKeystoneApplicationCredentialWithBodyWithResponse request with arbitrary body returning *CreateKeystoneApplicationCredentialResponse
func (c *ClientWithResponses) CreateKeystoneApplicationCredentialWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeystoneApplicationCredentialResponse, error) {
	rsp, err := c.CreateKeystoneApplicationCredentialWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneApplicationCredentialResponse(rsp)
}

func (c *ClientWithResponses) CreateKeystoneApplicationCredentialWithResponse(ctx context.Context, userId string, body CreateKeystoneApplicationCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeystoneApplicationCredentialResponse, error) {
	rsp, err := c.CreateKeystoneApplicationCredential(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeystoneApplicationCredentialResponse(rsp)
}

// GetPubkeysWithResponse request returning *GetPubkeysResponse
func (c *ClientWithResponses) GetPubkeysWithResponse(ctx context.Context, params *GetPubkeysParams, reqEditors ...RequestEditorFn) (*GetPubkeysResponse, error) {
	rsp, err := c.GetPubkeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPubkeysResponse(rsp)
}

// GetWebUserWithResponse request returning *GetWebUserResponse
func (c *ClientWithResponses) GetWebUserWithResponse(ctx context.Context, params *GetWebUserParams, reqEditors ...RequestEditorFn) (*GetWebUserResponse, error) {
	rsp, err := c.GetWebUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebUserResponse(rsp)
}

// ParseGetKeystoneVersionResponse parses an HTTP response from a GetKeystoneVersionWithResponse call
func ParseGetKeystoneVersionResponse(rsp *http.Response) (*GetKeystoneVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneFederationAuthTokenResponse parses an HTTP response from a CreateKeystoneFederationAuthTokenWithResponse call
func ParseCreateKeystoneFederationAuthTokenResponse(rsp *http.Response) (*CreateKeystoneFederationAuthTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneFederationAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneTokenResponse parses an HTTP response from a CreateKeystoneTokenWithResponse call
func ParseCreateKeystoneTokenResponse(rsp *http.Response) (*CreateKeystoneTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneDomainsResponse parses an HTTP response from a GetKeystoneDomainsWithResponse call
func ParseGetKeystoneDomainsResponse(rsp *http.Response) (*GetKeystoneDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneDomainsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneDomainResponse parses an HTTP response from a CreateKeystoneDomainWithResponse call
func ParseCreateKeystoneDomainResponse(rsp *http.Response) (*CreateKeystoneDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneDomainResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteKeystoneDomainByIDResponse parses an HTTP response from a DeleteKeystoneDomainByIDWithResponse call
func ParseDeleteKeystoneDomainByIDResponse(rsp *http.Response) (*DeleteKeystoneDomainByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeystoneDomainByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneDomainByIDResponse parses an HTTP response from a GetKeystoneDomainByIDWithResponse call
func ParseGetKeystoneDomainByIDResponse(rsp *http.Response) (*GetKeystoneDomainByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneDomainByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneDomainResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateKeystoneDomainByIDResponse parses an HTTP response from a UpdateKeystoneDomainByIDWithResponse call
func ParseUpdateKeystoneDomainByIDResponse(rsp *http.Response) (*UpdateKeystoneDomainByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKeystoneDomainByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneDomainResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnassignKeystoneRoleFromUserDomainResponse parses an HTTP response from a UnassignKeystoneRoleFromUserDomainWithResponse call
func ParseUnassignKeystoneRoleFromUserDomainResponse(rsp *http.Response) (*UnassignKeystoneRoleFromUserDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignKeystoneRoleFromUserDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssignKeystoneRoleToUserDomainResponse parses an HTTP response from a AssignKeystoneRoleToUserDomainWithResponse call
func ParseAssignKeystoneRoleToUserDomainResponse(rsp *http.Response) (*AssignKeystoneRoleToUserDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignKeystoneRoleToUserDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneGroupsResponse parses an HTTP response from a GetKeystoneGroupsWithResponse call
func ParseGetKeystoneGroupsResponse(rsp *http.Response) (*GetKeystoneGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneGroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneGroupByIDResponse parses an HTTP response from a GetKeystoneGroupByIDWithResponse call
func ParseGetKeystoneGroupByIDResponse(rsp *http.Response) (*GetKeystoneGroupByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneGroupByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneProjectsResponse parses an HTTP response from a GetKeystoneProjectsWithResponse call
func ParseGetKeystoneProjectsResponse(rsp *http.Response) (*GetKeystoneProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneProjectsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneProjectResponse parses an HTTP response from a CreateKeystoneProjectWithResponse call
func ParseCreateKeystoneProjectResponse(rsp *http.Response) (*CreateKeystoneProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteKeystoneProjectByIDResponse parses an HTTP response from a DeleteKeystoneProjectByIDWithResponse call
func ParseDeleteKeystoneProjectByIDResponse(rsp *http.Response) (*DeleteKeystoneProjectByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeystoneProjectByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneProjectByIDResponse parses an HTTP response from a GetKeystoneProjectByIDWithResponse call
func ParseGetKeystoneProjectByIDResponse(rsp *http.Response) (*GetKeystoneProjectByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneProjectByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateKeystoneProjectByIDResponse parses an HTTP response from a UpdateKeystoneProjectByIDWithResponse call
func ParseUpdateKeystoneProjectByIDResponse(rsp *http.Response) (*UpdateKeystoneProjectByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKeystoneProjectByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnassignKeystoneRoleFromGroupProjectResponse parses an HTTP response from a UnassignKeystoneRoleFromGroupProjectWithResponse call
func ParseUnassignKeystoneRoleFromGroupProjectResponse(rsp *http.Response) (*UnassignKeystoneRoleFromGroupProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignKeystoneRoleFromGroupProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssignKeystoneRoleToGroupProjectResponse parses an HTTP response from a AssignKeystoneRoleToGroupProjectWithResponse call
func ParseAssignKeystoneRoleToGroupProjectResponse(rsp *http.Response) (*AssignKeystoneRoleToGroupProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignKeystoneRoleToGroupProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnassignKeystoneRoleFromUserProjectResponse parses an HTTP response from a UnassignKeystoneRoleFromUserProjectWithResponse call
func ParseUnassignKeystoneRoleFromUserProjectResponse(rsp *http.Response) (*UnassignKeystoneRoleFromUserProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignKeystoneRoleFromUserProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssignKeystoneRoleToUserProjectResponse parses an HTTP response from a AssignKeystoneRoleToUserProjectWithResponse call
func ParseAssignKeystoneRoleToUserProjectResponse(rsp *http.Response) (*AssignKeystoneRoleToUserProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignKeystoneRoleToUserProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneRoleAssignmentsResponse parses an HTTP response from a GetKeystoneRoleAssignmentsWithResponse call
func ParseGetKeystoneRoleAssignmentsResponse(rsp *http.Response) (*GetKeystoneRoleAssignmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneRoleAssignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneRoleAssignmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneRolesResponse parses an HTTP response from a GetKeystoneRolesWithResponse call
func ParseGetKeystoneRolesResponse(rsp *http.Response) (*GetKeystoneRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneRolesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneRoleResponse parses an HTTP response from a CreateKeystoneRoleWithResponse call
func ParseCreateKeystoneRoleResponse(rsp *http.Response) (*CreateKeystoneRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneRoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteKeystoneRoleByIDResponse parses an HTTP response from a DeleteKeystoneRoleByIDWithResponse call
func ParseDeleteKeystoneRoleByIDResponse(rsp *http.Response) (*DeleteKeystoneRoleByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeystoneRoleByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneRoleByIDResponse parses an HTTP response from a GetKeystoneRoleByIDWithResponse call
func ParseGetKeystoneRoleByIDResponse(rsp *http.Response) (*GetKeystoneRoleByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneRoleByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneRoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateKeystoneRoleByIDResponse parses an HTTP response from a UpdateKeystoneRoleByIDWithResponse call
func ParseUpdateKeystoneRoleByIDResponse(rsp *http.Response) (*UpdateKeystoneRoleByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKeystoneRoleByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneRoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneUsersResponse parses an HTTP response from a GetKeystoneUsersWithResponse call
func ParseGetKeystoneUsersResponse(rsp *http.Response) (*GetKeystoneUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneUsers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneUserResponse parses an HTTP response from a CreateKeystoneUserWithResponse call
func ParseCreateKeystoneUserResponse(rsp *http.Response) (*CreateKeystoneUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteKeystoneUserByIDResponse parses an HTTP response from a DeleteKeystoneUserByIDWithResponse call
func ParseDeleteKeystoneUserByIDResponse(rsp *http.Response) (*DeleteKeystoneUserByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeystoneUserByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneUserByIDResponse parses an HTTP response from a GetKeystoneUserByIDWithResponse call
func ParseGetKeystoneUserByIDResponse(rsp *http.Response) (*GetKeystoneUserByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneUserByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeystoneUserProjectsByUserIDResponse parses an HTTP response from a GetKeystoneUserProjectsByUserIDWithResponse call
func ParseGetKeystoneUserProjectsByUserIDResponse(rsp *http.Response) (*GetKeystoneUserProjectsByUserIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeystoneUserProjectsByUserIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKeystoneApplicationCredentialResponse parses an HTTP response from a CreateKeystoneApplicationCredentialWithResponse call
func ParseCreateKeystoneApplicationCredentialResponse(rsp *http.Response) (*CreateKeystoneApplicationCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeystoneApplicationCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeystoneApplicationCredentialResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPubkeysResponse parses an HTTP response from a GetPubkeysWithResponse call
func ParseGetPubkeysResponse(rsp *http.Response) (*GetPubkeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPubkeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pubkeys
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWebUserResponse parses an HTTP response from a GetWebUserWithResponse call
func ParseGetWebUserResponse(rsp *http.Response) (*GetWebUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+w9aXPbOLJ/hcX3qt4XWaTkM/70PHGS9c7sxBXbu6nKulwQCVmciMcAoBNtSv99CxdP",
	"gCApybIzzJfIItjoG93oBvTD9uIwiSMYEWyf/7Cxt4AhYB/fAgKW8SP9CHw/IEEcgeU1ihOISADZkP9F",
	"cG6f2//j5EAcAcF5F/lJHETEXo9sskqgfW7Hsz+gx754iyAg8Fe4wiSO4EWSLAMP0BneIujDiARgeRUl",
	"KaGTJKUpQT72wcsGK8Z5HsT4AaVL/jf8DsJkCe3zL/cjOyAwZN/WEBNfAITAiv7tQ+yhIKHT0fFRulyC",
	"GQVDUAqz4ZigIHqk4+H3JEAQPwBSmtSeupPTA/f0YDq5nZyeH07Pp2f2yAwuAiEsA8IQPQUetBWDUdyG",
	"1nx8lVYMPQRJKzLTCEH6l0egX5pxDpY4f2EWx0sIIntNsYN/pgGiw79wsu5relEZpRH1vVGfLuMQBJFG",
	"gXz2sEGr16PqG2UdqMs8orzyC88yunMJVt5SMSSHZGSNIMLMimsU0wcaXiT86TaZwTF7CPytsWpkx+gR",
	"RMF/uCZoIBPwyPBrq+7NAijSYRSG5KJZGp/iJdSIghrvNuXQQe+MBDLczNTdxl+hzupAShamFUMH7YK+",
	"W3MO9MsuOF0IDMp4BcyrkNUmuF1JGNSHenECNwF2wwBUqc3Q7ErxVYG+MuUhJIvY72QzI5tQ4CouqlWt",
	"Wa0kBhJsV9puJK+1Tm0jIQjXqSKkBV7XORa69acXD0e2xgHqDd6A/B2GSGO1KYZIQQGcg3RJHgSjdR55",
	"FytBAjD+FiPf7NkUSKrd+0j6/gy20R8ytqi0NYt520l3ZAcRgWgOPDW1CD7q3HuKWMw7j1FIQ007RUE9",
	"JKw5Ebs4YwafQ1PSg1CsUAAv9mFtDeKDLfZslCNGuZFBppM/QkRBhxBj8KgFIx+baBLTyeH365HdmFWY",
	"E4XMGaoEmMfh7ql/Onnjz113fnj0Bs7PfHh66h8fTaE/dyeuV+RBmjLW14TIHWAZ7od3t6qhCeCrVz7Q",
	"eZqOXSeENArHqldkplB6K4yjgMRsyKiNqzDkQzngAretPFi35lSW2Zxju1vKdHbgTg+mp7eTs/ND9/z4",
	"zdhl/4q89QGBByQIlRlRVWjHZ/7JZD4/gyfw8Ah43uzw+Oz0yJ2c+BN/Bs5mKhjLIPqq0AcMl/My8AUh",
	"ybnjiC/GXhw6ctl2ng4d6jSwM/dPz07845Mjd+od+ZOTN5PD0yk89SF0fdedHTvqpAc7LVA3OoOadOvp",
	"ZZN+jOyyxy+I6nDinUznM3c+84/Ojmdv3hzDs5l74nqHc9d/c9aYrWYG17Ral1ZaGkY3J7A5augd+PPp",
	"71/B0VmYPNnbT2WLKwgnqaTRGVIl5ql8baPb+gRxEkcYdtkPacNOtY/cIBGXgAubR2V8oVgiu4tesaGU",
	"Sb5bTCTfN8UQOa7ijVFB3E3UXz7vHoOG+sxzteHuDVzOr8EjRL+xt1pnkEX9LxJRDLZYbj6yY/aEfuKY",
	"mTmoV/s8im5DnJBHh12U8pvYhEh3bZYo1XW5k9iKIlNS147dzxe48ke6rGC7YW0+lz7ElRz4gOI00Ym3",
	"VxLzrFaZW1ej06mRL5Oeh3IUpgyvDLvCTY6hkG3lbkE1dzcvwYSmt81HKdM2rOYKUKWCgzDigA1IdPcP",
	"Ap3duQeBVxs2F6DUyIvgd6IwWWMFIUHwKYhT3OddGXt3chPspUYqX9RmuM7v4od86au/tSvnkgAEI81O",
	"T0u71wUHOegidb2CBiFBvS223BqsakSXDf/Kuw2OobchZ6lEd6+SUWQoh2QTtGH7py2XLl5mONtDHylj",
	"LjAOHqMQqmKrTutTGVi2PGzIFVl26o6BTMJbVTzUIEStY5TtM3cHcUffVO5tqMdfdtl976407bWhMd58",
	"Vvy2BHrUJp0q82A7NZLXzgXpPveskJpqWrdEW2ls+YLVD0xjIa7BLfy11Wo3kQddLx5APknnCKSyJpoC",
	"kdp8bdddPfVdl7z27RDFt3bH/n48b8XpduytRBHa0sh207NbdesBSP2AZg8dGxm8fH+6EyvlvrYCZIsd",
	"lK7pXIBxCv1OEHu1dXR0z0wUhVRiB6WcLhEhA5QFguUmIakcucQr5Zliypmze1RoTpGGoa36l/DYY4BZ",
	"EsuGC3mRlk2XsZy/7cnQe8+sBak1GTWE9O1Gdd3cmyBNIczOpdhtc7izCqjBN7GliSPDDv3L3KGnMtPb",
	"chcvr3TwRp9M38JbDcFSCbHTYsexN4RgHHQbtv4TIiy2z8qEPeUP2qAl4FwCAmrYSFAt8GDvt/WUGe87",
	"MVDMRMWgihdC6AfggH7bG/Q/KIjbVaJuLSGApOpgKk2oCfo9PSOzOAE9hyW5VCashSQYf2qSWDAumCJy",
	"itjSvIYxYHxsC4RyrtawmgG8SXcGe10MViFync6+QkXjs/iyGTgdpAeq8ChJ/qCV8gnsjBvxAqwKlzum",
	"LK/r0EvvYy1lYn+KYy09jqz0P4hS5t+LOIjS89CJOgzcYVj+LzhTz1nYRGg8aZDvGWy/cNcuVdYHT6Ni",
	"rU8SpOyAx9BLUUBWNxQmZ8Dni5QsWJLxNwh8jka5m/t2AS0vxSQOLZCSRYzEMS7WsmOf2wv+nhSU/f2A",
	"DjvgGVpOaxL8yp3lZ3Za4XJ701EmHBTbs+Vca9blNI95w3tEAHcoMATBkg8jEIT/j7+Bx0eIxkGcQ73h",
	"31kX11fWLQShaD/iLcL43HEKL1V7qu0LC7MGVPY2WQBipRhiC1hSTiRG0ALYApElelUtEls+DOMIEwQI",
	"tOYQkBRBbAWRRRbQ+pjAiEI7HLsWTqAXzEU3J4szPChic4H9RQK8BbSmY7eG97dv38aAPR7H6NER72Ln",
	"t6u3736/eXcwHbvjBQmXTE0hCvHH+Y3sQlcQ77AxDuV9QJZFzl0XaLVHeVRrT8bu2OXJFIxAEtjn9iH7",
	"irfIM610vgqjcZ4OWZmV9wSX2fwBEkuOsyR8BhYx1lz5fFA14qYmxNMZNtfUdaWCiBJvoVnW+QNzp8jN",
	"sGM8ylWwjHUN4/XIPvr8eWso8AMfionTCH5PoEegb0E+ZiSP2Oxj8oI74qeccRqGAK10gqUvFNXC+Xhz",
	"8P7d5btPF7dXH3/P+vQfEhQ/BT5E2PkhP66dBMUk9uIl/5J9XDvyQGMSY4V28RNWFrAi+C3HRnq1spKV",
	"T2O9h754mPlW3iQDQkhY5vmlOpnElB22mGfvS5/Hjo5kvkkOtotrAd8tyKVUWy0VUzI+tJ2SDe405f0z",
	"GFp5p1GheExgFspGDMZGta+yBn+5X5cMsEn3a3ZIzchhz/AurEnaD9U7iMkvsb/aGge1h5/X5UCLavp6",
	"0OaXpM39dLXQ6m8OKfLue21IcZkNaXTv74MlfcIiOSk8a7aygJjDElu4zPP+mUK0yl2veLRfN1s9Q6EQ",
	"06OKdYOCanSKJpIdHGVWfGnylJdy0O5dZXGnak++snK8qCnSFkY2uE2j2/TzU1Yqv+n8CPw119klJIqT",
	"35fs+9yvzVbW1WVNbfmosiB/WbGBjW706tKK51VkeebM0FGGrmxjYJOg9ahOppiZT+sP+qSV/HqkX2cN",
	"SlJbZTfSkDkk3mJHCjL4the44tYVMQFUBWqqyHfVTdqoKtS8JIXc/oKvL00NC/5rNAq1njeu9OLCix/0",
	"vwf6N+ujc36wjl5DJHAX8ZZfC1h0OFV5YFFAVhxlSNTNTLxVLHK9R3F4hyHKwtt9G9zIMCejsnlGwdGt",
	"TivZ3DCtENz2AyI2dyqEB31rjuJQJe/BEOuW0cArUd2tVJd62NVFzapu48GmXoFNZRallvNgT+3sobbM",
	"5Uf6lflJl+3qQqLyQR7I77kbyLB68ZuBlesSTHuBgtWDqla2AiVf1KqZbbU05M9cXYzpM5NXj2SFg391",
	"yXP5RpGmNIETOGQJtdS5qFg1/Sw2QJmLKIXWJK2CXudjejpOMctGrnPUdjpxjYBqEvEon6R1Y+BzWEbt",
	"QguT686EN5iGTq07FnJkf2dzJec6G7X7Uk6pD3dPWzvVW1+anLY09cFtG6s5SeHUvdKFt6/nSK63KegI",
	"afaIOOQseyjpyKmHmo6iplOWfnNRp1lT6qv+ZmryukLTwc9tJTytqaOptNOsk8pzKS9KLXdd3RligJ+p",
	"wFMxj8bFP9ttYP9vpcjDk0e2+6aLdnVlHpa658Hv3o1vtIUdEsnYn73WoxD7YJXaao+aW23rPS1MTFXx",
	"GczrdZZ9BtNqW/hRcap5/dtdi0PXxe8OQ/SKjHPocqhX7gfr7NDm0GPdMxuXrtFhMKxX2+owGFXLXgft",
	"iqe68dNcuSsIRd7bqd3Lq9xb2r+QxyYVPwdSL6/Rp2N+3c7mZTzBOu1k9OkWJxNdU9rp2CXcYz5qi9NW",
	"pGiaX+iQCYHn2CzV3YVrKlrW9HZwHCbLVnqMDm7C6Bs29QgvvSWqfF1wGw0d1HKl1qSOBXV2x1BzNf0T",
	"H7L7Unp+JdOe9tBLt2Y3baAzoxp2z40VdCQvD697x/a1c8bsNoVzKr4edScZCz53yZzNO9TLFfXygsSb",
	"i+UNqlFZQTfQi9dVIx982IbV8bLymUrjDRpYv2/w5Sjhriviw1L+ExTCi5ZQXcOzO6C3ef7jTtz+3DPV",
	"YfsRLz3V4TSaUhzO3kEbKylOxpYuKY645LMpxbnD2XVwu01x2L1h+/SL4hpUvT9kRjT4Q2Nqk8r7ZOtu",
	"sX1qw5jdJrWhYusRPchayHOnNmzeIbVRpDYFiTenNg2qUVkxN9CL15XaDL6rZ0pTVDq9x2p3Mo2O/z/c",
	"6lxaoXCMf1nxKzP/MoraKvkYFFalsFUV0+ls1nRUQPPBQ5BdZQyWna9TLYCxcjCG0PEif+lt8Z0ta3mf",
	"loX754holfTvNcRVYjT0xW83/NXYCjPVp4lT+C0Y5UryCZIURdhK0tky8BjYfyu3BuSvzRgM6msQ+dSk",
	"cniaPQA68MWsF5I4hVAKhAx3blcvuFdoT6Z53+DMkb8H0qh6dJBa5+SvnZgvnWfeQtsSIgY87LEZRJIy",
	"aNjmt7oXFYdPUH679kswAgBET1KB8t8SOXecyfR07I7d8cRe36//GwAA//92R4WjhqAAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
